<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <meta name="description" content="JavaScript 基础知识1.//单行注释
2./多行注释/
3.//给html元素绑定点击事件，点击这个元素的时候，触发一个方法，弹出一段文字的方法
123document.documentElement.onclick=function () &amp;#123;       alert(&amp;apos" />
  

  
  
  
  
  
  
  <title>JavaScript | 秋月</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="JavaScript 基础知识1.//单行注释 2./多行注释/ 3.//给html元素绑定点击事件，点击这个元素的时候，触发一个方法，弹出一段文字的方法 123document.documentElement.onclick=function () &amp;#123;       alert(&amp;apos;点不到&amp;apos;)&amp;#125; //写在外联式里面的代码块不会生效 123&amp;lt;script">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript">
<meta property="og:url" content="http://yoursite.com/2017/07/18/JavaScript /index.html">
<meta property="og:site_name" content="秋月">
<meta property="og:description" content="JavaScript 基础知识1.//单行注释 2./多行注释/ 3.//给html元素绑定点击事件，点击这个元素的时候，触发一个方法，弹出一段文字的方法 123document.documentElement.onclick=function () &amp;#123;       alert(&amp;apos;点不到&amp;apos;)&amp;#125; //写在外联式里面的代码块不会生效 123&amp;lt;script">
<meta property="og:image" content="http://yoursite.com/images/javascript/栈内存和堆内存.png">
<meta property="og:image" content="http://yoursite.com/images/javascript/栈内存里产生堆内存.png">
<meta property="og:image" content="http://yoursite.com/images/javascript/作用域选项卡.png">
<meta property="og:image" content="http://yoursite.com/images/javascript/原型链.png">
<meta property="og:image" content="http://yoursite.com/images/javascript/简单交互过程.png">
<meta property="og:image" content="http://yoursite.com/images/javascript/插入排序.png">
<meta property="og:updated_time" content="2017-09-11T09:38:42.767Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript">
<meta name="twitter:description" content="JavaScript 基础知识1.//单行注释 2./多行注释/ 3.//给html元素绑定点击事件，点击这个元素的时候，触发一个方法，弹出一段文字的方法 123document.documentElement.onclick=function () &amp;#123;       alert(&amp;apos;点不到&amp;apos;)&amp;#125; //写在外联式里面的代码块不会生效 123&amp;lt;script">
<meta name="twitter:image" content="http://yoursite.com/images/javascript/栈内存和堆内存.png">
  
  
    <link rel="icon" href="/css/images/me.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  

  
  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>
</head>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/" title="秋月" rel="home">秋月</a>
      </h1>
      
        <script type="text/javascript" src="http://api.hitokoto.us/rand?encode=js&charset=utf-8"></script>
        <h2 class="site-description"><script>hitokoto();</script></h2>
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/">Home</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/archives">Archives</a></li>
                
                </ul>
            </div>
    </nav>
</header>
      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main"><article id="post-JavaScript " class="post-JavaScript  post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title article-title">
      JavaScript
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2017/07/18/JavaScript /" data-id="cj7fzno8c0000c8fxbknue7v5" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="JavaScript-基础知识"><a href="#JavaScript-基础知识" class="headerlink" title="JavaScript 基础知识"></a>JavaScript 基础知识</h1><p>1.//单行注释</p>
<p>2./<em>多行注释</em>/</p>
<p>3.//给html元素绑定点击事件，点击这个元素的时候，触发一个方法，弹出一段文字的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">document.documentElement.onclick=function () &#123;</div><div class="line">       alert(&apos;点不到&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>//写在外联式里面的代码块不会生效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;link.js&quot; type=&quot;text/javascript&quot;&gt;</div><div class="line">document.write(&apos;&lt;h1&gt;我&lt;/h1&gt;&apos;);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<h2 id="js的输出方式"><a href="#js的输出方式" class="headerlink" title="js的输出方式"></a>js的输出方式</h2><ul>
<li><p>document.write(‘content’) – 向文档内输出，不会覆盖原文档的内容</p>
</li>
<li><p>console 在控制台输出 【开发者工具】</p>
<ul>
<li><p>console.log() 向控制台输出一条消息</p>
</li>
<li><p>console.dir() 输出一个对象的全部属性（输出结果类似于 DOM 面板中的样式）</p>
</li>
<li><p>console.error() 向控制台抛出异常</p>
</li>
<li><p>console.clear() 清空控制台</p>
<ul>
<li>ctrl+L</li>
<li>右键 clear console</li>
<li>点击禁止图标直接清空控制台</li>
</ul>
</li>
</ul>
</li>
<li>alert() 方法用于显示带有一条指定消息 （弹出）</li>
<li>innerHTML/innerText 获取或者向指定元素内添加内容<ul>
<li>innerHTML() 获取元素内所有的内容（包括元素）</li>
<li>innerText() 获取元素内的文本内容<br>这种方法会将元素内原有的内容覆盖掉</li>
</ul>
</li>
</ul>
<h2 id="js的命名规范"><a href="#js的命名规范" class="headerlink" title="js的命名规范"></a>js的命名规范</h2><ul>
<li>严格区分大小写</li>
<li>命名时名称中可以出现字母、数字、下划线 、$，但是数字不能为首位</li>
<li>推荐使用驼峰命名法：由多个有意义单词组成名称的时候，第一个单词首字母小写，其余单词首字母大写</li>
<li>不能使用ECMAScript中规定的关键字和保留字</li>
<li>变量命名时推荐使用匈牙利命名法【使用数据类型为名称前缀】</li>
</ul>
<h2 id="js中的变量"><a href="#js中的变量" class="headerlink" title="js中的变量"></a>js中的变量</h2><p>变量是用来储存信息的容器，由于js是松散数据类型，所以变量中可以放置任何的数据类型</p>
<h2 id="创建变量的语法"><a href="#创建变量的语法" class="headerlink" title="创建变量的语法"></a>创建变量的语法</h2><p>声明 变量名; 此时这个变量中什么都没有 获取变量中的值时，返回值undefined</p>
<p>如何赋值 一个等号</p>
<p>var obj={}; 声明一个变量叫做obj将{}赋值给这个变量</p>
<p>“=” 在js中是赋值的意义 将等号右侧的值给到等号左侧</p>
<p>“+=” 保留原有值，在原有值上累加</p>
<p>num+=2;</p>
<p>num*=4;</p>
<p>num/=2;</p>
<p>num-=2;</p>
<p>num%=2; 取余数</p>
<p>一条声明可以有多个变量，每一个变量用逗号隔开</p>
<p>p.s：一般会相同数据类型使用一个声明</p>
<ul>
<li>var ary=[];</li>
<li>var obj={};</li>
<li>var num=1;</li>
<li>var str=’’;</li>
<li>var ary=[],obj={},num=1,str=’’;</li>
</ul>
<h2 id="js中的数据类型"><a href="#js中的数据类型" class="headerlink" title="js中的数据类型"></a>js中的数据类型</h2><ul>
<li>基本数据类型：<br>包括数字（number），字符串（string），布尔（boolean），null，undefined</li>
<li>引用数据类型：包括对象数据类型和函数数据类型<ul>
<li>对象数据类型：包括数组类（Array），对象类（Object），正则类（RegExp）……</li>
<li>函数数据类型：function</li>
</ul>
</li>
</ul>
<h2 id="数字数据类型-number"><a href="#数字数据类型-number" class="headerlink" title="数字数据类型 number"></a>数字数据类型 number</h2><p>包括 整数（正整数 0 负整数） 小数（浮点数 Float）NaN（not a number）</p>
<h2 id="Number-valve-方法"><a href="#Number-valve-方法" class="headerlink" title="Number(valve) 方法"></a>Number(valve) 方法</h2><p>这种方法是强制转化，只要要转化的对象中有一个内容不是数字，那么就会返回NaN</p>
<p>作用（应用场景）：将其他数据类型转为数字数据类型</p>
<p>返回值（最终结果）：数字或者NaN</p>
<p>如果转化的是字符串 ，直接调用Number() 方法将字符串转为数字，如果字符串中有一项不是数字返回NaN</p>
<p>如果转化的是对象数据类型 ，先调用 .toString() 方法，将数组中的内容转为字符串，再用上一条规则转为数字</p>
<p>如果转化布尔类型，true –&gt;1 false –&gt; 0</p>
<p>null –&gt; 0</p>
<p>undefined –&gt; NaN</p>
<h3 id="parseFloat-value"><a href="#parseFloat-value" class="headerlink" title="parseFloat(value)"></a>parseFloat(value)</h3><p>作用：将字符串转化为数字（可转化为浮点数）</p>
<p>机制：将值从左到右依次查找，遇到第一个非有效数字停止查找，将之前的值返回</p>
<p>返回值：数字或NaN</p>
<h3 id="parseInt-value"><a href="#parseInt-value" class="headerlink" title="parseInt(value)"></a>parseInt(value)</h3><p>作用：将字符串转化为一个整数</p>
<p>机制：将值从左到右查找，找到第一个非有效整数停止，将查找到的值返回</p>
<p>返回值：数字或NaN</p>
<h3 id="isNaN-value-–-gt-返回值为布尔类型值"><a href="#isNaN-value-–-gt-返回值为布尔类型值" class="headerlink" title="isNaN(value) –&gt; 返回值为布尔类型值"></a>isNaN(value) –&gt; 返回值为布尔类型值</h3><p>is not a number 这不是一个数字</p>
<p>作用：判断一个值不是数字</p>
<p>不是数字的时候返回 true</p>
<p>是数字的时候返回 false</p>
<p>机制：isNaN在判断之前会先将非数字数据类型的值，调用Number()方法，将其转化为数字数据类型，如果Number()转化结构为NaN的时候，isNaN()返回true，反之为false</p>
<p>返回值：true或false</p>
<p>isNaN(36)–&gt;false</p>
<p>“==” 在js中是比较的意思，返回一个布尔类型值</p>
<p>相等返回true 不相等返回false</p>
<p>NaN==NaN – &gt; false</p>
<p>Number()</p>
<p>parseFloat()</p>
<p>parseInt()</p>
<h2 id="字符串-string"><a href="#字符串-string" class="headerlink" title="字符串 string"></a>字符串 string</h2><p>是用来储存字符的变量，字符串在js中没有任何意义</p>
<h2 id="null"><a href="#null" class="headerlink" title="null"></a>null</h2><p>现在预留位置为空，之后再添加值</p>
<h2 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h2><p>现在没有，将来也没有</p>
<p>布尔数据类型 boolean [ˈbuliən]</p>
<p>布尔有两个值 true 和 false</p>
<p>判断一个值是真是假</p>
<p>在js中 0 、NaN 、” 、 null 、undefined 为假，其余都为真</p>
<h2 id="Boolean-value"><a href="#Boolean-value" class="headerlink" title="Boolean(value)"></a>Boolean(value)</h2><p>作用：判断一个值是真是假</p>
<p>返回值：true或false</p>
<p>判断一个条件是否成立</p>
<h3 id="一个叹号-–-gt-取反"><a href="#一个叹号-–-gt-取反" class="headerlink" title="! 一个叹号 –&gt; 取反"></a>! 一个叹号 –&gt; 取反</h3><p>机制：先将!后面的值调用Boolean()方法转为布尔类型后取反</p>
<p>返回值：true或false</p>
<p>1.console.log(!0) –&gt; true</p>
<p>2.1.Boolean(0)–&gt; false</p>
<p>3.2.!false–&gt;true</p>
<h3 id="两个叹号-–-gt-将其他数据类型转为布尔类型（取反再取反）"><a href="#两个叹号-–-gt-将其他数据类型转为布尔类型（取反再取反）" class="headerlink" title="! ! 两个叹号 –&gt; 将其他数据类型转为布尔类型（取反再取反）"></a>! ! 两个叹号 –&gt; 将其他数据类型转为布尔类型（取反再取反）</h3><p>和Boolean()方法得到的值相同</p>
<p>返回值：true或false</p>
<p>1.console.log(!!0) –&gt; false</p>
<p>2.1.Boolean(0) –&gt; false</p>
<p>3.2.!false–&gt;true</p>
<p>4.3.!true–&gt;false</p>
<h2 id="对象数据类型-object"><a href="#对象数据类型-object" class="headerlink" title="对象数据类型 object"></a>对象数据类型 object</h2><p>包括数组类（Array），对象类（Object），正则类（RegExp）……</p>
<h3 id="对象类（Object）"><a href="#对象类（Object）" class="headerlink" title="对象类（Object）"></a>对象类（Object）</h3><p>由键值对组成，这些键值对是用来描述这个对象的，每一对键值对之间用逗号隔开<br>键值对由属性名和属性值组成 key:value</p>
<p>创建对象的实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1.//字面量创建方式</div><div class="line">2.var obj1=&#123;</div><div class="line">3.        key:&apos;value&apos;,</div><div class="line">4.        key1:&apos;value1&apos;</div><div class="line">5.&#125;</div><div class="line">6.//实例创建方式</div><div class="line">7.var obj2=new Object();</div></pre></td></tr></table></figure>
<p>对象的属性：</p>
<ul>
<li>内置属性：对象天生自带的</li>
<li><p>自定义属性：人为定义的<br>对象的属性是用来描述对象的，还可以储存值</p>
<h3 id="js中用来储存值的方式"><a href="#js中用来储存值的方式" class="headerlink" title="js中用来储存值的方式"></a>js中用来储存值的方式</h3></li>
<li><p>变量</p>
</li>
<li>属性<br>对象的属性名可以为数字</li>
</ul>
<h3 id="访问对象的方式"><a href="#访问对象的方式" class="headerlink" title="访问对象的方式"></a>访问对象的方式</h3><p>对象名.属性名</p>
<p>对象名[‘属性名’]</p>
<h3 id="增加属性的方式"><a href="#增加属性的方式" class="headerlink" title="增加属性的方式"></a>增加属性的方式</h3><p>自定义属性的过程，需要增加属性名和属性值</p>
<p>对象名.新的属性名=属性值</p>
<p>对象名[‘新的属性名’]=属性值</p>
<h3 id="删除属性的方式"><a href="#删除属性的方式" class="headerlink" title="删除属性的方式"></a>删除属性的方式</h3><p>delete 对象名.属性名</p>
<p>delete 对象名[属性名]</p>
<h3 id="修改属性值的方式"><a href="#修改属性值的方式" class="headerlink" title="修改属性值的方式"></a>修改属性值的方式</h3><p>就是将之前有的属性名里面的属性值重新赋值</p>
<p>对象名.属性名=新的属性值</p>
<p>对象名[‘属性名’]=新的属性值</p>
<p>属性名为数字的时候，获取属性的方式为：对象名[‘属性名’]，这个方法也适用其他属性名，属性名为数字的时候可以省略引号，其他属性名省略引号，系统默认这个属性名为变量</p>
<h2 id="基本数据类型和引用数据类型的区别"><a href="#基本数据类型和引用数据类型的区别" class="headerlink" title="基本数据类型和引用数据类型的区别"></a>基本数据类型和引用数据类型的区别</h2><p>基本数据类型直接对值进行操作</p>
<p>引用数据类型操作的是内存地址</p>
<blockquote>
<p>1、浏览器提供给代码运行的环境，代码在这里从上到下执行</p>
<p>2、当遇到引用数据类型的时候，浏览器会开辟一个新的内存空间，将引用数据类型中的代码当做字符串存到这个里面</p>
<p>3、开辟的空间会返回给对象一个地址，那么此时这个对象储存的不是代码而是一个地址</p>
<p>4、当将这个对象赋值给另一个对象的时候，其实赋值过程是将地址传递给另一个对象了<br>    也就是说，这两个对象将要访问同一个地址，也就是说他们操作的是同一份代码</p>
</blockquote>
<h2 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h2><p>在js中其他数据类型+=一个字符串的话，全部会变成字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var str1=&apos;&apos;;</div><div class="line">   str1+=true;</div><div class="line">   console.log(str1);//&apos;true&apos;</div></pre></td></tr></table></figure>
<h2 id="js中数据类型的检测"><a href="#js中数据类型的检测" class="headerlink" title="js中数据类型的检测"></a>js中数据类型的检测</h2><h3 id="typeof-value"><a href="#typeof-value" class="headerlink" title="typeof value"></a>typeof value</h3><p>返回值永远是一个<strong>字符串</strong>里面包着数据类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">typeof undefined --&gt; &apos;undefined&apos;</div><div class="line">typeof 1 --&gt; &apos;number&apos;</div><div class="line">typeof &apos;&apos; --&gt; &apos;string&apos;</div><div class="line">typeof true --&gt; &apos;boolean&apos;</div><div class="line">typeof []--&gt; &apos;object&apos;</div><div class="line">typeof &#123;&#125; --&gt; &apos;object&apos;</div><div class="line">typeof null--&gt; &apos;object&apos;</div><div class="line">typeof function ()&#123;&#125;--&gt; &apos;function&apos;</div><div class="line">typeof 不能具体细分object下面的数据类型</div><div class="line">typeof 人为null也是object下的数据类型</div><div class="line"></div><div class="line">/*typeof (typeof (typeof (typeof (typeof undefined))))</div><div class="line">    &apos;string&apos;*/</div></pre></td></tr></table></figure></p>
<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>运算返回值是布尔类型的值<br>判断已知对象数据类型的方法<br>（判断一个实例是否属于这个类–&gt;例如：[] 是不是属于数组类）<br>instanceof 在检测的时候 基本数据类型不能检测</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">value instanceof Class</div></pre></td></tr></table></figure>
<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>运算返回值是布尔类型的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[1,2,3].constructor === Array</div></pre></td></tr></table></figure>
<p>=== 绝对比较  左右两侧的数据类型完全一致</p>
<h3 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a>Object.prototype.toString.call()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(Object.prototype.toString.call(&apos;陈&apos;) === &apos;[object String]&apos;)---&gt; true</div></pre></td></tr></table></figure>
<h2 id="数据类型之间的比较"><a href="#数据类型之间的比较" class="headerlink" title="数据类型之间的比较"></a>数据类型之间的比较</h2><ul>
<li>对象==对象 永远为false<ul>
<li>({}=={})     []==[]   {}==[]</li>
</ul>
</li>
<li>数字==字符串 字符串调用Number()方法，将字符串转为数字，然后再进行比较</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1==&apos;1&apos;</div><div class="line">1==Number(&apos;1&apos;)</div></pre></td></tr></table></figure>
<ul>
<li>数字==布尔 布尔转为数字数据类型，调用Number()</li>
</ul>
<p>true = 1  false = 0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1==false</div><div class="line">1==Number(false)</div><div class="line">1==0</div></pre></td></tr></table></figure>
<ul>
<li>数字==对象  对象调用.toString()变成字符串，字符串调用Number()方法变成数字</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">1==[]</div><div class="line">1==[].toString() --&gt; 1==&apos;&apos; --&gt; 1==Number(&apos;&apos;)--&gt; 1==0 --&gt; false</div><div class="line"></div><div class="line">1==[1]</div><div class="line">1==[1].toString() --&gt; 1==&apos;1&apos; --&gt; 1==Number(&apos;1&apos;)--&gt; 1==1 --&gt; true</div><div class="line"></div><div class="line">1==&#123;&#125;</div><div class="line">1==&#123;&#125;.toString() --&gt; 1==&quot;[object Object]&quot; --&gt; 1==Number(&quot;[object Object]&quot;)--&gt; 1==NaN --&gt; false</div><div class="line"></div><div class="line">&#123;&#125;.toString() --&gt; &quot;[object Object]&quot;</div></pre></td></tr></table></figure>
<ul>
<li>对象==字符串  对象调用.toString()变成字符串</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&apos;&apos;==[]</div><div class="line">&apos;&apos;==[].toString()--&gt;&apos;&apos;==&apos;&apos; --&gt;true</div><div class="line"></div><div class="line">&apos;&apos;==&#123;&#125;</div><div class="line">&apos;&apos;==&apos;[object Object]&apos; --&gt; false</div></pre></td></tr></table></figure>
<ul>
<li><p>字符串==布尔  双方都变成数字数据类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">12==true  -- &gt; false</div></pre></td></tr></table></figure>
</li>
<li><p>对象==布尔 双方转化为数字</p>
</li>
<li><p>null==undefined    true</p>
</li>
<li>null===undefined   false  ===要求等号两侧的数据类型一致</li>
<li>NaN==NaN false</li>
</ul>
<blockquote>
<p>对象和其他数据类型比较的时候，最先都要转为字符串<br>最终比较的时候，其实都是数字数据类型在比较</p>
</blockquote>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li><p>函数是由事件驱动的或者当它被调用时执行的可重复使用的代码块</p>
</li>
<li><p>语法：函数就是包裹在花括号中的代码块，前面使用了关键词 function，</p>
</li>
<li><p>例如</p>
</li>
</ul>
<p>定义部分：<br>function 函数名(形参1,形参2…){//可传可不传，形参是一个变量</p>
<pre><code>这里是要执行的代码
</code></pre><p>}//当定义形参而没有传递实参的时候，形参获取到的值是undefined</p>
<p>执行部分：</p>
<p>函数名(实参1，实参2….);//我们将形参和实参统称为参数</p>
<ul>
<li>方法本身没有意义，只有在使用的时候实现了对应的功能，才有意义</li>
<li>函数只有在调用或执行的时候才会生效</li>
<li>函数一次定义，可以多次执行</li>
<li>当函数执行的时候这个私有作用域将函数体中的代码都包起来，保护了里面的私有变量不受外界的干扰（外部获取不到也修改不了），我们将函数执行的时候形成的这种保护机制叫做“闭包”</li>
<li><p>函数分为实名函数和匿名函数</p>
<ul>
<li>匿名函数分为自执行函数和函数表达式<ul>
<li>自执行函数：定义和执行一起完成</li>
</ul>
</li>
</ul>
</li>
<li><p>函数表达式:将函数定义的部分当做值赋值给变量或者元素的某一个行为</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">oDiv.onclick=function()&#123;&#125;;</div></pre></td></tr></table></figure>
<blockquote>
<p>函数：实名函数</p>
<p>形参：函数执行的时候，方法中需要变量</p>
<p>实参：在执行的时候，传递的具体的参数，也就是给形参赋的实际意义</p>
<p>return：方法执行的产物</p>
<p>arguments：是个类数组；索引；callee；length</p>
<p>匿名函数：自执行函数和函数表达式</p>
</blockquote>
<h2 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h2><h3 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">(条件) --&gt; true/false</div><div class="line"></div><div class="line">1 if(条件)&#123;条件成立执行的代码&#125;</div><div class="line"></div><div class="line">2 if(条件)&#123;条件成立执行的代码&#125;else&#123;条件不成立执行的代码&#125;</div><div class="line"></div><div class="line">3 if(条件1)&#123;</div><div class="line">	条件1成立执行的代码</div><div class="line">&#125;else if(条件2)&#123;</div><div class="line">	条件2成立执行的代码</div><div class="line">&#125;else if(条件3)&#123;</div><div class="line">	条件3成立执行的代码</div><div class="line">&#125;....else&#123;</div><div class="line">	以上条件都不成立执行的代码</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>是绝对比较（条件和值进行比较的时候必须是相同数据类型），用在不同值的不同操作上面</p>
<p>ps：如果成立的条件后面没有break，那么这个判断会从成立的那个条件开始，一直执行到最后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var n=1;</div><div class="line">     switch (n)&#123;</div><div class="line">	     case &apos;0&apos;:</div><div class="line">		     alert(&apos;0&apos;);</div><div class="line">		     break;//如果break跟着的这个条件成立，就跳出（中断）判断，不会继续执行判断了</div><div class="line">	     case &apos;1&apos;:</div><div class="line">		     alert(&apos;1&apos;);</div><div class="line">		     break;</div><div class="line">	     default:</div><div class="line">		     alert(&apos;以上都不成立&apos;);</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<h3 id="三元运算符-（条件运算符-三目运算符）"><a href="#三元运算符-（条件运算符-三目运算符）" class="headerlink" title="三元运算符 （条件运算符/三目运算符）"></a>三元运算符 （条件运算符/三目运算符）</h3><p>基于某些条件对变量进行赋值的条件运算符</p>
<p>声明 变量名=(条件)?条件成立时将这个值给变量:条件不成立将这个值给到变量;</p>
<p>var num=(!0)?2:3;  – &gt;  num=2</p>
<p>!0?alert(‘ok’):void (0);</p>
<p>void (0) 用来占位</p>
<p>!0?(alert(‘ok’),console.log(‘ok’)):(alert(‘no’),console.log(‘no’));</p>
<p>如果要执行的是多个语句，需要将这些语句放在一个括号中，用逗号隔开</p>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>for循环适用于已知循环次数</p>
<ul>
<li>声明一个变量 设置初始值</li>
<li>设定循环范围</li>
<li>执行循环体中的代码</li>
<li>设置初始值的累加操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for(var i=0;i&lt;=3;i++)&#123;</div><div class="line">	循环体中的代码</div><div class="line">	//i++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="break出现在循环体中，break后面的代码不再执行，整个循环结束"><a href="#break出现在循环体中，break后面的代码不再执行，整个循环结束" class="headerlink" title="break出现在循环体中，break后面的代码不再执行，整个循环结束"></a>break出现在循环体中，break后面的代码不再执行，整个循环结束</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for (var i=0;i&lt;3;i++)&#123;</div><div class="line">        console.log(i);// 0</div><div class="line">        break;</div><div class="line">        i++;//两个i++都不会再执行了</div><div class="line">    &#125;</div><div class="line">    console.log(i);// 0</div></pre></td></tr></table></figure>
<h4 id="continue出现正在循环体中，循环体continue后面的代码不执行，但是循环依然正常"><a href="#continue出现正在循环体中，循环体continue后面的代码不执行，但是循环依然正常" class="headerlink" title="continue出现正在循环体中，循环体continue后面的代码不执行，但是循环依然正常"></a>continue出现正在循环体中，循环体continue后面的代码不执行，但是循环依然正常</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for (var i=0;i&lt;3;i++)&#123;</div><div class="line">     console.log(i);// 0 1 2</div><div class="line">        continue;</div><div class="line">     i++;//只有这一行受到了影响</div><div class="line">     &#125;</div><div class="line">     console.log(i);// 3</div></pre></td></tr></table></figure>
<blockquote>
<p>i++  – &gt; 先赋值 再累加<br>++i  – &gt; 先在自身累加 再赋值</p>
</blockquote>
<h3 id="for-in循环"><a href="#for-in循环" class="headerlink" title="for in循环"></a>for in循环</h3><p>作用：遍历对象的属性名和属性值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var obj=&#123;</div><div class="line">        name:&apos;陈&apos;,</div><div class="line">        age:&apos;22&apos;,</div><div class="line">        url:&apos;www.chenhuiqiuyue.cn&apos;</div><div class="line">    &#125;;</div><div class="line">    for (var key in obj)&#123;</div><div class="line">        //key 变量  代表这个对象的属性名</div><div class="line">        console.log(obj[key]);</div><div class="line">        //在遍历对象时，不知道这个对象的属性名是否存在数字，所以只能用对象名[变量名]的形式获取属性值</div><div class="line">        //obj[key] 中括号中是变量 而不是一个属性 所以不能加引号</div><div class="line">    &#125;</div><div class="line">    //for in循环只能遍历可枚举属性 （自定义属性）</div></pre></td></tr></table></figure>
<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">while (//循环的判断条件)&#123;</div><div class="line">//条件成立执行的代码&#125;</div><div class="line">var num = 1;</div><div class="line">   while (num &lt; 100) &#123;</div><div class="line">       console.log(num+=4);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h3 id="获取DOM中html标签的方式"><a href="#获取DOM中html标签的方式" class="headerlink" title="获取DOM中html标签的方式"></a>获取DOM中html标签的方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">document.getElementById(&apos;main&apos;)</div><div class="line">// 获取的到的是，id=&apos;main&apos;的这个DOM节点，包含他的子节点。</div><div class="line"></div><div class="line">//document.getElementsByTagName();</div><div class="line">//document.getElementsByClassName();</div><div class="line">上边这两个方法，获取到的是节点集合，可以理解为是一个数组，所以它不能使用DOM的getElement这个方法了。</div><div class="line"></div><div class="line">//document.querySelectorAll();</div><div class="line">   括号里边填写(&apos;.类名&apos;) (&apos;html标签名&apos;) (&apos;#id名&apos;)</div><div class="line">   这个方法获取到的DOM，也是一个节点集合，也可以理解为，一个数组，所以它也不能使用DOM的getElement这个方法了。</div><div class="line"></div><div class="line"></div><div class="line">//document.getElementsByName();</div><div class="line">&lt;li&gt;&lt;input type=&quot;text&quot; name=&quot;zs&quot; id=&quot;zs&quot; value=&quot;杀手&quot;&gt;&lt;/li&gt;</div><div class="line">document.getElementsByName(&apos;zs&apos;);</div><div class="line">括号里边填写(&apos;name的值&apos;)，获取到的对象是节点集合，也可以理解为一个数组，所以它也不能使用DOM的getElement这个方法了。</div></pre></td></tr></table></figure>
<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><h2 id="获取DOM对象的方法"><a href="#获取DOM对象的方法" class="headerlink" title="获取DOM对象的方法"></a>获取DOM对象的方法</h2><ul>
<li>通过id获取一个元素</li>
</ul>
<p><code>document.getElementById(&#39;idName&#39;)</code></p>
<ul>
<li><p>document是获取范围，通过id获取的时候，范围只能是document</p>
</li>
<li><p>如果页面上有两个以上相同的id名称，获取第一个</p>
</li>
<li><p>在ie67中，会将表单元素的name属性值当做id名称来调取，并且不区分大小写</p>
</li>
<li><p>可以直接调用id代表这个元素（不推荐）</p>
</li>
</ul>
<ul>
<li>通过标签名获取一组元素</li>
</ul>
<p><code>document.getElementsByTagName(&#39;tagName&#39;)</code></p>
<ul>
<li><p>获取到的是一个集合，类数组（索引、长度）</p>
</li>
<li><p>document是一个可以变的范围</p>
</li>
<li><p>获取的时候通过集合中的索引来进行获取 obj[0] / obj.item(0)</p>
</li>
</ul>
<ul>
<li>通过标签属性name的值获取一组元素</li>
</ul>
<p><code>document.getElementsByName(&#39;name&#39;)</code></p>
<ul>
<li><p>获取到的是一个集合，类数组（索引、长度）</p>
</li>
<li><p>document是一个可以变的范围</p>
</li>
<li><p>获取的时候通过集合中的索引来进行获取 obj[0] / obj.item(0)</p>
</li>
<li><p>在ie6-9浏览器下，只对表单元素起作用</p>
</li>
</ul>
<ul>
<li>通过标签属性class的值获取一组元素</li>
</ul>
<p><code>document.getElementsByClassName(&#39;className&#39;)</code></p>
<ul>
<li><p>获取到的是一个集合，类数组（索引、长度）</p>
</li>
<li><p>document是一个可以变的范围</p>
</li>
<li><p>获取的时候通过集合中的索引来进行获取 obj[0] / obj.item(0)</p>
</li>
<li><p>在ie678中报错</p>
</li>
</ul>
<ul>
<li><p>通过根元素获取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1.document.documentElement//获取html元素</div><div class="line">2.document.body //获取body元素</div><div class="line">3.//获取当前页面的宽度和高度</div><div class="line">4.var width=document.documentElement.clientWidth||document.body.clientWidth</div><div class="line">5.//client [ˈklaɪənt] 客户端 当前 当事人</div><div class="line">6.var height=document.documentElement.clientHeight||document.body.clientHeight</div></pre></td></tr></table></figure>
</li>
<li><p>在移动端我们获取元素常用的方法（ ie678不兼容）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1.document.querySelector(&quot;#id&quot;);//获取一个</div><div class="line">2.document.querySelectorAll(&quot;.class&quot;);//获取一组</div><div class="line">3.document.querySelectorAll(&quot;#tab li&quot;);</div><div class="line">4.p.s：选择器参考css选择器的规则</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="DOM节点"><a href="#DOM节点" class="headerlink" title="DOM节点"></a>DOM节点</h2><p>Node 在页面中出现的所有东西都是节点，元素、注释、文本等都是节点</p>
<p>应用场景：通过节点可以进行DOM对象的增删改查</p>
<p>常用的DOM节点有哪些？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">1.childNodes 获取所有的子节点（一组）</div><div class="line">2.children   获取所有元素子节点（一组）</div><div class="line">3.parentNode 获取父亲节点</div><div class="line">4.previousSibling 获取上一个节点</div><div class="line">5.previousElementSibling 上一个元素节点（不兼容）</div><div class="line">6.nextSibling 获取弟弟节点</div><div class="line">7.nextElementSibling下一个元素节点（不兼容）</div><div class="line">8.firstChild 获取子节点中的第一个</div><div class="line">9.firstElementChild （不兼容）</div><div class="line">10.lastChild  获取子节点中最后一个</div></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">节点类型</th>
<th style="text-align:center">nodeType</th>
<th style="text-align:center">nodeName</th>
<th>nodeValue</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">元素节点（元素标签）</td>
<td style="text-align:center">1</td>
<td style="text-align:center">大写的标签名</td>
<td>null</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">文本节点（文字）</td>
<td style="text-align:center">3</td>
<td style="text-align:center">text</td>
<td>文字内容</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">注释节点（注释）</td>
<td style="text-align:center">8</td>
<td style="text-align:center">comment</td>
<td>注释内容</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">document（整个文档）</td>
<td style="text-align:center">9</td>
<td style="text-align:center">document</td>
<td>null</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="DOM节点的增删改查"><a href="#DOM节点的增删改查" class="headerlink" title="DOM节点的增删改查"></a>DOM节点的增删改查</h2><h3 id="创建元素节点"><a href="#创建元素节点" class="headerlink" title="创建元素节点"></a>创建元素节点</h3><p>createElement() create[kriˈet] 创造 创建</p>
<h3 id="将新创建的元素节点添加到指定元素所有内容之后（末尾）"><a href="#将新创建的元素节点添加到指定元素所有内容之后（末尾）" class="headerlink" title="将新创建的元素节点添加到指定元素所有内容之后（末尾）"></a>将新创建的元素节点添加到指定元素所有内容之后（末尾）</h3><p>oDiv.parentNode.appendChild(oDiv);</p>
<blockquote>
<p>appendChild 前是oDiv的父级元素节点</p>
</blockquote>
<h3 id="将创建的元素添加到已有元素之前"><a href="#将创建的元素添加到已有元素之前" class="headerlink" title="将创建的元素添加到已有元素之前"></a>将创建的元素添加到已有元素之前</h3><p>父级元素.insertBefore(要放置的元素，放在谁之前)</p>
<p>oldTag.parentNode.insertBefore(newTag,oldTag)</p>
<blockquote>
<p>创建的元素于已有元素为兄弟关系</p>
</blockquote>
<h3 id="创建属性节点"><a href="#创建属性节点" class="headerlink" title="创建属性节点"></a>创建属性节点</h3><p>setAttribute(属性名,属性值)–直接向对象添加一对键值对 attribute[əˈtrɪbjut] 属性</p>
<p>这个属性会在html标签中显示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.oDiv.setAttribute(&apos;qiuyue&apos;,&apos;chenhui&apos;);//显示在标签内</div><div class="line">2.console.log(oDiv.getAttribute(&apos;chenhui&apos;));</div><div class="line">3.oDiv.removeAttribute(&apos;chnehui&apos;);</div></pre></td></tr></table></figure></p>
<h3 id="删除创建的元素节点"><a href="#删除创建的元素节点" class="headerlink" title="删除创建的元素节点"></a>删除创建的元素节点</h3><p>父级元素.removeChild(删除的对象)</p>
<p>oDiv.parentNode.removeChild(oDiv)</p>
<p>已有的和新创建的元素节点都可以移除</p>
<h3 id="克隆元素节点-kloʊn"><a href="#克隆元素节点-kloʊn" class="headerlink" title="克隆元素节点 [kloʊn]"></a>克隆元素节点 [kloʊn]</h3><p>oDiv.cloneNode(true)</p>
<p>默认参数为false（不填参数）：只克隆当前元素</p>
<p>true ：克隆当前元素与元素的所有子节点</p>
<h3 id="替换元素节点-rɪˈples"><a href="#替换元素节点-rɪˈples" class="headerlink" title="替换元素节点 [rɪˈples]"></a>替换元素节点 [rɪˈples]</h3><p>父级元素.replaceChild(替换的对象，被替换的对象)</p>
<p>oDiv.parentNode.replaceChild(替换的对象，被替换的对象)</p>
<h2 id="Math方法及应用"><a href="#Math方法及应用" class="headerlink" title="Math方法及应用"></a>Math方法及应用</h2><ul>
<li><p>Math.abs() 取绝对值</p>
</li>
<li><p>Math.ceil()向上取整 （出现小数点就向上＋1） [si:l]</p>
</li>
<li><p>Math.floor()向下取整 [flɔr]</p>
</li>
<li><p>Math.round()四舍五入 [raʊnd]</p>
</li>
<li><p>Math.max(val1,val2,val3…)取最大值</p>
</li>
<li><p>Math.min(val1,val2,val3…)取最小值</p>
</li>
<li><p>Math.random()获取[0-1)之间的随机小数（不包含1）[ˈrændəm]</p>
</li>
<li><p>Math.round(Math.random()*(m-n)+n) 获取任意两个数之间的随机数</p>
</li>
</ul>
<h1 id="Array数组"><a href="#Array数组" class="headerlink" title="Array数组"></a>Array数组</h1><p>思考要点    什么方法改变原数组      什么方法不改变      什么方法返回查找项或删除项     什么方法返回长度</p>
<p>删除数组末尾项的方法：</p>
<ul>
<li><p>pop()</p>
</li>
<li><p>ary.length- -</p>
</li>
<li><p>ary.splice(ary.length-1,1)/ary.splice(ary.length-1)</p>
</li>
</ul>
<p>向数组末尾添加</p>
<ul>
<li><p>push()</p>
</li>
<li><p>ary.splice(ary.length,0,x)</p>
</li>
</ul>
<p>向数组开始添加</p>
<ul>
<li><p>unshift()</p>
</li>
<li><p>ary.splice(0,0,x)</p>
</li>
</ul>
<h2 id="数组中的方法-四个方面-分析"><a href="#数组中的方法-四个方面-分析" class="headerlink" title="数组中的方法 四个方面 分析"></a>数组中的方法 四个方面 分析</h2><p>1、作用</p>
<p>2、参数</p>
<p>3、返回值</p>
<p>4、原数组是否改变</p>
<h3 id="1-push-向数组末尾添加一项或多项-返回的是增加后的数组长度-原数组改变"><a href="#1-push-向数组末尾添加一项或多项-返回的是增加后的数组长度-原数组改变" class="headerlink" title="1.push 向数组末尾添加一项或多项 返回的是增加后的数组长度  原数组改变"></a>1.push 向数组末尾添加一项或多项 返回的是增加后的数组长度  原数组改变</h3><h3 id="2-pop-删除数组末尾最后一项-返回的是删除的内容-原数组改变"><a href="#2-pop-删除数组末尾最后一项-返回的是删除的内容-原数组改变" class="headerlink" title="2.pop  删除数组末尾最后一项 返回的是删除的内容 原数组改变"></a>2.pop  删除数组末尾最后一项 返回的是删除的内容 原数组改变</h3><h3 id="3-unshift-向数组开头添加一项或多项-返回的是增加后的数组长度-原数组改变"><a href="#3-unshift-向数组开头添加一项或多项-返回的是增加后的数组长度-原数组改变" class="headerlink" title="3.unshift 向数组开头添加一项或多项 返回的是增加后的数组长度 原数组改变"></a>3.unshift 向数组开头添加一项或多项 返回的是增加后的数组长度 原数组改变</h3><h3 id="4-shift-删除数组开头第一项-返回的删除的内容-原数组改变"><a href="#4-shift-删除数组开头第一项-返回的删除的内容-原数组改变" class="headerlink" title="4.shift 删除数组开头第一项 返回的删除的内容 原数组改变"></a>4.shift 删除数组开头第一项 返回的删除的内容 原数组改变</h3><h3 id="5-splice"><a href="#5-splice" class="headerlink" title="5.splice"></a>5.splice</h3><p>splice() 什么都没做 返回值 空数组</p>
<p>splice(x) 当一个参数时候 从索引x开始删除到末尾 将删除的内容组成一个新数组返回 原数组发生改变</p>
<p>splice(x,y) 从索引x开始删除y个 将删除的内容组成一个新数组返回 原数组改变</p>
<p>splice(x,y,z) 从索引x开始删除y个，将删除的内容替换为z 将删除的内容组成一个新数组返回 原数组改变</p>
<p>splice(x,0,z) 从索引x开始删除0个，将z插入到原来数组x位置那项的前面（此时x位置变成了z 其余的往后错一位） 返回一个空数组 原数组改变</p>
<h3 id="6-slice-截取-原数组没有改变"><a href="#6-slice-截取-原数组没有改变" class="headerlink" title="6.slice 截取 原数组没有改变"></a>6.slice 截取 原数组没有改变</h3><p>slice()/slice(0) 复制一份原数组 组成一个新数组 原数组没有改变</p>
<p>slice(x) 从索引x开始 截取到末尾  返回截取到的内容组成的新数组 原数组没有改变</p>
<p>slice(x,y) 从索引x开始 截取到索引y处 但不包含索引y处那一项 将找到内容返回 组成一个新数组</p>
<p>slice(x,负数) 从索引x开始 截取到索引（length+ 负数）将找到内容返回 组成一个新数组</p>
<p>slice(负数) 从索引（length+负数）将找到内容返回 组成一个新数组</p>
<h3 id="7-concat-x-拼接-参数就是我要拼接的内容-返回一个拼接后的新数组-原数组没有改变"><a href="#7-concat-x-拼接-参数就是我要拼接的内容-返回一个拼接后的新数组-原数组没有改变" class="headerlink" title="7.concat(x) 拼接 参数就是我要拼接的内容 返回一个拼接后的新数组 原数组没有改变"></a>7.concat(x) 拼接 参数就是我要拼接的内容 返回一个拼接后的新数组 原数组没有改变</h3><h3 id="8-toString-将数组转化为字符串-返回值string-原数组不变"><a href="#8-toString-将数组转化为字符串-返回值string-原数组不变" class="headerlink" title="8.toString() 将数组转化为字符串 返回值string 原数组不变"></a>8.toString() 将数组转化为字符串 返回值string 原数组不变</h3><p>join(x) 将数组按照指定分隔符 转化为字符串</p>
<p> 数组求和 eval 将字符转化为字符串表达式</p>
<p> var name = ‘nihao’;</p>
<p> console.log(name);</p>
<p> console.log(eval(‘name’)); // nihao</p>
<p> 数组排列和排序</p>
<h3 id="9-reverse-将数组倒过来排列-原数组改变-并且也返回一个排列后的新数组"><a href="#9-reverse-将数组倒过来排列-原数组改变-并且也返回一个排列后的新数组" class="headerlink" title="9.reverse 将数组倒过来排列 原数组改变 并且也返回一个排列后的新数组"></a>9.reverse 将数组倒过来排列 原数组改变 并且也返回一个排列后的新数组</h3><h3 id="10-sort-排序-默认只能将10以内的数从小到大排序-返回一个排序后的新数组-原数组改变"><a href="#10-sort-排序-默认只能将10以内的数从小到大排序-返回一个排序后的新数组-原数组改变" class="headerlink" title="10.sort 排序 // 默认只能将10以内的数从小到大排序 返回一个排序后的新数组 原数组改变"></a>10.sort 排序 // 默认只能将10以内的数从小到大排序 返回一个排序后的新数组 原数组改变</h3><p>function(a,b){ return a - b } 将数组从小到大完全排序</p>
<p> function(a,b){ return b - a } 将数组从大到小完全排序</p>
<p>ie不兼容 ie 6-8</p>
<h3 id="11-indexOf-和-lastIndexOf-根据指定参数-在数组中返回参数的索引位置-找到的那个参数-索引是几就返回几"><a href="#11-indexOf-和-lastIndexOf-根据指定参数-在数组中返回参数的索引位置-找到的那个参数-索引是几就返回几" class="headerlink" title="11.indexOf 和 lastIndexOf 根据指定参数 在数组中返回参数的索引位置 找到的那个参数 索引是几就返回几"></a>11.indexOf 和 lastIndexOf 根据指定参数 在数组中返回参数的索引位置 找到的那个参数 索引是几就返回几</h3><p> 如果当前数组中找不到就返回 -1<br>区别<br>indexOf 返回的是 查找的这个参数 在数组中第一次出现的索引位置</p>
<p>lastIndexOf 返回的是 查找的这个参数 在数组中最后一次出现的索引位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var arr = [4,5,6,1,9,2,6,10,6,20];// [1,10,2,20,4,5,6,9]</div><div class="line">var arr2 = arr.indexOf(6);</div><div class="line">console.log(arr2);</div><div class="line">console.log(arr);</div></pre></td></tr></table></figure>
<h3 id="forEach-map-filter-循环遍历数组"><a href="#forEach-map-filter-循环遍历数组" class="headerlink" title="forEach/map/filter 循环遍历数组"></a>forEach/map/filter 循环遍历数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var arr = [&apos;aa&apos;,&apos;bb&apos;,&apos;cc&apos;,100];</div><div class="line">for(var i = 0; i &lt; arr.length; i++)&#123;</div><div class="line">          console.log(arr[i]);</div><div class="line">&#125;</div><div class="line">//    当前数组中有多少项 就执行多少次</div><div class="line"> arr.forEach(function (item, ind) &#123; //item代表的是当前数组中的每一项 ind 代表的是数组中每一项的索引</div><div class="line">console.log(ind + &apos;：&apos;+ item);</div><div class="line">console.log(1);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h4 id="map-修改-将修改后的返回组成一个新数组-原数组不变"><a href="#map-修改-将修改后的返回组成一个新数组-原数组不变" class="headerlink" title="map 修改 将修改后的返回组成一个新数组 原数组不变"></a>map 修改 将修改后的返回组成一个新数组 原数组不变</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var arr = [1,2,3,4];</div><div class="line">var arr2 = arr.map(function (item, ind) &#123;</div><div class="line">//         return item * 10</div><div class="line">if(ind === 1)&#123; // 将索引为1的那一项修改为 &apos;nihao&apos;</div><div class="line">    return &apos;nihao&apos;</div><div class="line">&#125;</div><div class="line"> return item; // 处了所以为1的那一项 其他的照常返回</div><div class="line">&#125;);</div><div class="line">console.log(arr);</div><div class="line">console.log(arr2);</div></pre></td></tr></table></figure>
<h4 id="filter-查找过滤"><a href="#filter-查找过滤" class="headerlink" title="filter 查找过滤"></a>filter 查找过滤</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var arr = [1,2,4,3,4,4];</div><div class="line">var arr2 = arr.filter(function (item, ind) &#123;</div><div class="line">         if(item === 4)&#123; // 将原数组中 为4的返回出来组成一个新数组 原数组不改变</div><div class="line">             return item;</div><div class="line">         &#125;</div><div class="line">&#125;);</div><div class="line">console.log(arr);</div><div class="line">console.log(arr2); // [4，4,4]</div></pre></td></tr></table></figure>
<h1 id="字符串-string-1"><a href="#字符串-string-1" class="headerlink" title="字符串 string"></a>字符串 string</h1><p>字符串是js中代表字符的变量，字符用引号包裹，单引号或者双引号都可以</p>
<p>‘’ ‘abc’ ‘1 2 3’</p>
<p>‘1   2’</p>
<p>字符串是有长度和索引</p>
<h2 id="获取指定索引位置的字符"><a href="#获取指定索引位置的字符" class="headerlink" title="获取指定索引位置的字符"></a>获取指定索引位置的字符</h2><ul>
<li><p>chartAt(索引)/charCodeAt：根据索引获取指定位置的字符（或者或者字符的Unicode编码值）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var str =&apos;abcde&apos;;</div><div class="line">var str1 = str.charAt(0);</div><div class="line">console.log(str1);</div></pre></td></tr></table></figure>
</li>
<li><p>String.fromCharCode([unicode编码])：通过指定的编码获取对应的字符</p>
<h2 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h2></li>
<li>substr(n,m) 从索引n开始，截取m个字符（m不写截取到末尾），n和m不支持负数</li>
</ul>
<p>原字符串不改变，返回查找到的字符</p>
<ul>
<li>substring(n,m) 从索引n开始找到索引m处，不包含m</li>
</ul>
<p>原字符串不改变，返回查找到的字符</p>
<ul>
<li>slice(n,m)  从索引n开始找到索引m处，不包含m(这个方法支持参数负值)</li>
</ul>
<p>公式： str.length+负数索引</p>
<p>原字符串不改变，返回查找到字符</p>
<h2 id="查找字符所在字符串的索引"><a href="#查找字符所在字符串的索引" class="headerlink" title="查找字符所在字符串的索引"></a>查找字符所在字符串的索引</h2><ul>
<li><p>indexOf(‘value’)返回该值第一次出现所在位置的索引</p>
</li>
<li><p>lastIndexOf(‘value’)返回该值最后一次出现所在位置的索引</p>
</li>
<li><p>search(‘value’)：和indexOf相同，都是获取字符出现位置的索引，只有search可以支持正则</p>
</li>
<li><p>返值位 -1 说明该值不存在于这个字符串</p>
</li>
<li><p>match(‘value’)返回一个数组，数组中是匹配到的字符，根据正则匹配到所有符合规则的结果，最后以一个数组来存储</p>
</li>
</ul>
<h2 id="字符串内字母大小写"><a href="#字符串内字母大小写" class="headerlink" title="字符串内字母大小写"></a>字符串内字母大小写</h2><ul>
<li><p>toLowerCase()转化为小写</p>
</li>
<li><p>toUpperCase()转化为大写</p>
</li>
</ul>
<h2 id="替换与正则表达式匹配的字串"><a href="#替换与正则表达式匹配的字串" class="headerlink" title="替换与正则表达式匹配的字串"></a>替换与正则表达式匹配的字串</h2><p>replace(oldWord,newWord)把字符串中原有字符串进替换，在不使用正则的情况下，执行一次，只能替换一次，这个方法也可以支持正则</p>
<p>如果不配合正则使用的话 只能替换第一次查找到的字符</p>
<h2 id="将字符串按照指定分隔符产分成数组"><a href="#将字符串按照指定分隔符产分成数组" class="headerlink" title="将字符串按照指定分隔符产分成数组"></a>将字符串按照指定分隔符产分成数组</h2><p>split (分隔符)</p>
<p>split() 将字符串当做一项转为数组</p>
<p>split(‘’)将字符串的每一项都当做数组中的每一项分隔符要在字符串中存在 并且分隔符分隔后不会在数组中</p>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>localeCompare: 两个字符串之间的比较，按照每一个字符的Unicode编码值一个个比较</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>trim/trimLeft/trimRight：去除字符串的首尾空格（trimLeft去除首空格/trimRight去除尾空格），但是这个方法不兼容</p>
<h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><p>传递的参数 第一个参数为 方法（也就是一个函数），第二个参数为 时间</p>
<h2 id="指定一个时间，重复执行一个方法"><a href="#指定一个时间，重复执行一个方法" class="headerlink" title="指定一个时间，重复执行一个方法"></a>指定一个时间，重复执行一个方法</h2><p>window.setInterval([function],[interval])</p>
<h2 id="指定一个时间，达到时间后执行一个方法，只执行一次"><a href="#指定一个时间，达到时间后执行一个方法，只执行一次" class="headerlink" title="指定一个时间，达到时间后执行一个方法，只执行一次"></a>指定一个时间，达到时间后执行一个方法，只执行一次</h2><p>window.setTimeout([function],[interval])</p>
<p>定时器的返回值是一个数字，代表我是这个文档下第几个定时器</p>
<p>清除定时器 不一定是timeout定义的就一定要用timeout清除，可以通用</p>
<p>window.clearTimeout()</p>
<p>window.clearInterval()</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>函数自己调用自己</p>
<hr>
<h1 id="javascript知识"><a href="#javascript知识" class="headerlink" title="javascript知识"></a>javascript知识</h1><h2 id="1、预解释（变量提升）"><a href="#1、预解释（变量提升）" class="headerlink" title="1、预解释（变量提升）"></a>1、预解释（变量提升）</h2><blockquote>
<p>浏览器加载html时候，会提供一个供js代码执行的环境 -&gt; window(全局作用域)</p>
</blockquote>
<p>在当前作用域中，js代码执行之前，把所有带var和带function关键字的进行声明或者定义</p>
<ul>
<li><p>var和function的预解释的区别</p>
<ul>
<li><p>通过var声明的时候 会给变量赋值一个默认值undefined</p>
</li>
<li><p>预解释的时候 带var只声明 不定义</p>
</li>
<li><p>带function 预解释的时候 声明加定义 预解释完成后 代码自上而下开始执行</p>
</li>
</ul>
</li>
<li><p>全局变量和私有变量</p>
<ul>
<li><p>全局变量 就是 在全局作用域中声明的变量</p>
</li>
<li><p>私有变量 就是 在私有作用域中声明的变量（形参和预解释的声明的变量）</p>
</li>
<li><p>函数执行 将函数里的js代码加载运行 也需要一个供函数里js代码执行的环境 -&gt;私有作用域【1、给形参赋值–&gt;2、进行预解释–&gt;3、从上到下执行】</p>
</li>
</ul>
</li>
</ul>
<p>预解释是针对于当前作用域 只发生在当前作用域中 首先开始对window进行预解释 函数执行的时候会形成一个私有作用域 然后 函数执行的时候也会进行 预解释</p>
<h2 id="2、作用域链"><a href="#2、作用域链" class="headerlink" title="2、作用域链"></a>2、作用域链</h2><p>如果在私用作用域遇到一个变量，首先看是不是形参或者有没有在当前作用域预解释的时候声明过，如果没有声明过也不是形参 就会去上级作用域中查找，一直找到window为止</p>
<p>如何看上级作用域，就看 函数是在哪里定义的</p>
<h2 id="3、预解释无节操"><a href="#3、预解释无节操" class="headerlink" title="3、预解释无节操"></a>3、预解释无节操</h2><p>1、不管if条件是否成立都会进行预解释</p>
<p>2、预解释的时候不会 声明等号右边的【return 下面的代码虽然不执行，也要进行预解释；但是return 右边 不会进行预解释 因为把它当做一个值返回出去】</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>1、闭包：当一个方法在运行的时候，就会形成一个私有作用域，在这个作用域里，里面定义的变量不会受到上级作用域或其他作用域的影响，不会和全局或其它作用域里的变量有冲突。这个由方法运行而产生的私有作用作用域，就叫闭包。【闭包为函数运行机制】</p>
<p>2、闭包其实就是函数在运行的时候产生的那个私有作用域。【为了让变量更安全，让一个环境中的变量与其它环境中的变量隔离开不产生冲突】</p>
<p>3、例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">var name = &apos;chenhui&apos;;</div><div class="line">var age = &apos;twenty-two&apos;;</div><div class="line">//定义一个匿名函数再让这个匿名函数运行，并给匿名函数传递参数</div><div class="line">(function (chinaName, chinaAge) &#123;//这里是给匿名方法定义的形式参数</div><div class="line">    var name = &apos;陈卉&apos;;</div><div class="line">    var age = 22;</div><div class="line">    console.log(chinaName + &apos;有&apos; + chinaAge + &apos;岁。&apos; + name + &apos;有&apos; + age + &apos;岁。&apos;);//chenhui有twenty-two岁。陈卉有22岁。</div><div class="line">&#125;)(name, age);//这里是给匿名方法传的函数</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p>在这个例子里，定义了两个全局变量name和age，下面的匿名函数里也定义了变量name和age，但这两组相同的变量互不影响，匿名方法的变量属于自己的私用有的作用域，这个运行的匿名方法就形成闭包。如果这个匿名方法想用到全局变量name和age，也可以通过传参数的方式传给这个匿名函数。有名函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function fn(chinaName, chinaAge) &#123;//给刚才的匿名函数一个是有名函数而已</div><div class="line">    var name = &apos;陈卉&apos;;</div><div class="line">    var age = 22;</div><div class="line">    console.log(chinaName + &apos;有&apos; + chinaAge + &apos;岁。&apos; + name + &apos;有&apos; + age + &apos;岁。&apos;);。</div><div class="line">&#125;</div><div class="line">fn(name, age);//让函数执行  chenhui有twenty-two岁。陈卉有22岁</div></pre></td></tr></table></figure></p>
<p>让这个匿名函数访问到全局变量name和age还有一种方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(function (chinaName, chinaAge) &#123;</div><div class="line">    var name = &apos;陈卉&apos;;</div><div class="line">    var age = 22;</div><div class="line">    console.log(window.name + &apos;有&apos; + window.age + &apos;岁。&apos; + name + &apos;有&apos; + age + &apos;岁。&apos;);//chenhui有twenty-two岁。陈卉有22岁。</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>定义在闭包里的变量和函数在全局下不能使用的，如何让定义在闭包里的函数能在闭包外面使用，方法是把它赋值给一个全局变量，如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(function (chinaName, chinaAge) &#123;</div><div class="line">    var name = &apos;陈卉&apos;;</div><div class="line">    var age = 22;</div><div class="line">    function change()&#123;//这个函数是私有，外部不能访问，这就形成了一个闭包方法</div><div class="line">     console.log(window.name + &apos;有&apos; + window.age + &apos;岁。&apos; + name + &apos;有&apos; + age + &apos;岁。&apos;);</div><div class="line">    &#125;</div><div class="line">    window.chenhuiqiuyue=change;</div><div class="line">&#125;)();</div><div class="line">    chenhuiqiuyue();//运行这个方法  chenhui有twenty-two岁。陈卉有22岁。</div></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="重复声明"><a href="#重复声明" class="headerlink" title="重复声明"></a>重复声明</h2><p>预解释 带var不重复声明 带function 不重复声明 但重复定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function fn = log(2) = log(12) = log(13)(var fn 不重复声明) = log(123)</div><div class="line">console.log(fn);//输出函数本身 function fn()&#123;console.log(123)&#125;</div><div class="line">fn();//123</div><div class="line">function fn() &#123;console.log(2)&#125;</div><div class="line">fn(); //123</div><div class="line">function fn() &#123;console.log(12)&#125;</div><div class="line">fn();//123</div><div class="line">function fn() &#123;console.log(13)&#125;</div><div class="line">var fn = 666; //fn = 123</div><div class="line">function fn () &#123; console.log(123)&#125;</div><div class="line">console.log(fn) ;//666</div><div class="line">fn();// 666() 报错 fn is not a function</div></pre></td></tr></table></figure></p>
<p>计算例1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function fn2(num)&#123;</div><div class="line">   num  = 123; //num = 20 修改为 num = 123;</div><div class="line">   var num = 100; //num = 100;</div><div class="line">   return function () &#123;</div><div class="line">      console.log(num);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">var f2 = f2(20);</div><div class="line">f2();//100;</div></pre></td></tr></table></figure></p>
<p>计算例2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">console.log(fn2);</div><div class="line">function fn2()&#123;  //A</div><div class="line">    console.log(2222);</div><div class="line">&#125;</div><div class="line">fn2();</div><div class="line">function fn2()&#123; //B B把A覆盖掉</div><div class="line">    console.log(6666);</div><div class="line">&#125;</div><div class="line">fn2();</div><div class="line">console.log(ni); //undefined</div><div class="line">var ni = 123;</div><div class="line">console.log(ni);// 123</div><div class="line">var ni = 666;</div><div class="line">console.log(ni);//666</div></pre></td></tr></table></figure></p>
<h2 id="堆内存和栈内存"><a href="#堆内存和栈内存" class="headerlink" title="堆内存和栈内存"></a>堆内存和栈内存</h2><p>1、推内存  用来存储引用数据类型的值</p>
<p>2、栈内存 供js代码执行的环境</p>
<p><img src="/images/javascript/栈内存和堆内存.png"></p>
<p>3、堆内存释放</p>
<ul>
<li>浏览器默认机制 每间隔一段时间 会把那些 没有被占用的 内存回收释放</li>
</ul>
<p>4、栈内存销毁与不销毁<br>window（栈内存）关闭浏览器的时候会销毁<br>一般情况下函数形成私有作用域（栈内存）执行完里面代码 就会立即销毁</p>
<p>5、模拟简单投票 利用全局不销毁的情况 来实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">&lt;p&gt;</div><div class="line">   &quot;点赞&quot;</div><div class="line">   &lt;span id=&quot; totals&quot;&gt;0&lt;/span&gt;</div><div class="line">&lt;/p&gt;</div><div class="line">&lt;button&gt;点赞&lt;button&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">   var btn = document.getElementByTagName(&apos;button&apos;)[0];</div><div class="line">   var totals = document.getElementById(&apos;totals&apos;);</div><div class="line">   //利用全局作用域不销毁的情况 来保存我们每一次修改count的值</div><div class="line">   var count = 0;</div><div class="line">   btn.onclick = function()&#123;</div><div class="line">       count++;</div><div class="line">       totals.innerHTML = count;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   //自己创建一个不销毁的作用域 来保存每一次修改后count的值</div><div class="line">   ~(function()&#123;</div><div class="line">        var count = 0;</div><div class="line">        function f()&#123;</div><div class="line">            count++;</div><div class="line">            totals.innerHTML = count;</div><div class="line">        &#125;</div><div class="line">        btn.onclick = f;</div><div class="line">   &#125;)()</div><div class="line"></div><div class="line">   //btn主动去里面占用 自执行函数里 定义的 function</div><div class="line">   ~(function()&#123;</div><div class="line">         var count = 0;</div><div class="line">         btn.onclick = function ()&#123;</div><div class="line">             count++;</div><div class="line">             totals.innerHTML = count;</div><div class="line">         &#125;;</div><div class="line">   &#125;)()</div><div class="line"></div><div class="line">   //btn在外面等着 自执行函数 主动将在它里面定义的function 让拜托你接收</div><div class="line">   btn.onclick = (function()&#123;</div><div class="line">       var count = 0;</div><div class="line">       return function()&#123;</div><div class="line">         console.log(count);</div><div class="line">         count++;</div><div class="line">         totals.innerHTML = count;</div><div class="line">       &#125;</div><div class="line">   &#125;)();</div><div class="line">   console.log(btn.onclick);</div><div class="line"></div><div class="line">   // 内容自身加一</div><div class="line">   btn.onclick = function()&#123;</div><div class="line">        totals.innerHTML = ++totals.innerHTML;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   //利用自定义属性</div><div class="line">   btn.count = 0;</div><div class="line">   btn.onclick = function()&#123;</div><div class="line">       totals.innerHTML = ++this.count;</div><div class="line">   &#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure></p>
<p><img src="/images/javascript/栈内存里产生堆内存.png"></p>
<p>7、利用作用作用域不销毁完成选项卡<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div></pre></td><td class="code"><pre><div class="line">&lt;style&gt;</div><div class="line">      *&#123;</div><div class="line">         margin: 0;</div><div class="line">         padding: 0;</div><div class="line">      &#125;</div><div class="line">      a&#123;</div><div class="line">         text-decoration: none;</div><div class="line">      &#125;</div><div class="line">      ul&#123;</div><div class="line">         list-style: none;</div><div class="line">         width:302px;</div><div class="line">      &#125;</div><div class="line">      body&#123;</div><div class="line">          font: 12px/1.5 &quot;Microsoft Himalaya&quot;;</div><div class="line">          background: #59afe4;</div><div class="line">      &#125;</div><div class="line">      .box&#123;</div><div class="line">           margin: 30px auto;</div><div class="line">           width: 300px;</div><div class="line">           boder: 1px solid #222；</div><div class="line">           boder-radius: 3px;</div><div class="line">           background: #fff;</div><div class="line">           overflow: hidden;</div><div class="line">      &#125;</div><div class="line">      .clearfix:after&#123;</div><div class="line">          display: block;</div><div class="line">          content: &quot;&quot;;</div><div class="line">          clear: both;</div><div class="line">      &#125;</div><div class="line">      ul li&#123;</div><div class="line">           float: left;</div><div class="line">           boder-bottom: 1px solid #222;</div><div class="line">           width: 74px;</div><div class="line">           height: 41px;</div><div class="line">           line-height: 41px;</div><div class="line">           text-align: center;</div><div class="line">           cursor: pointer;</div><div class="line">      &#125;</div><div class="line">      ul li.cur &#123;</div><div class="line">           margin-left: -1px;</div><div class="line">           padding-right: 3px;</div><div class="line">           border-bottom-color: #fff;</div><div class="line">           border-left: 1px solid #222;</div><div class="line">           border-right: 1px solid #222;</div><div class="line">           width: 150px;</div><div class="line">      &#125;</div><div class="line">      p&#123;</div><div class="line">          display: none;</div><div class="line">          text-align: center;</div><div class="line">          line-height: 50px;</div><div class="line">      &#125;</div><div class="line">      p.cur&#123;</div><div class="line">           display: block;</div><div class="line">      &#125;</div><div class="line">      ul li a&#123;</div><div class="line">           color: orangered;</div><div class="line">           font-size: 10px;</div><div class="line">      &#125;</div><div class="line">      ul li a:hover&#123;</div><div class="line">            text-decoration: underline;</div><div class="line">      &#125;</div><div class="line">      ul li span&#123;</div><div class="line">          color: orangered;</div><div class="line">          display: none;</div><div class="line">      &#125;</div><div class="line">      ul li.cur span&#123;</div><div class="line">         discplay: inline-block;</div><div class="line">      &#125;</div><div class="line">&lt;/style&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;div class= &quot;box&quot;&gt;</div><div class="line">  &lt;ul class=&quot;clearfix&quot;&gt;</div><div class="line">     &lt;li&gt;</div><div class="line">       我的电影</div><div class="line">       &lt;span&gt;</div><div class="line">           /</div><div class="line">          &lt;a href=&quot;#&quot;&gt;更多&lt;/a&gt;</div><div class="line">       &lt;/span&gt;</div><div class="line">     &lt;/li&gt;</div><div class="line">     &lt;li class=&quot;cur&quot;&gt;</div><div class="line">       我的音乐</div><div class="line">       &lt;span&gt;</div><div class="line">           /</div><div class="line">          &lt;a href=&quot;#&quot;&gt;更多&lt;/a&gt;</div><div class="line">       &lt;/span&gt;</div><div class="line">     &lt;/li&gt;</div><div class="line">     &lt;li&gt;</div><div class="line">       我的电视剧</div><div class="line">       &lt;span&gt;</div><div class="line">          /</div><div class="line">          &lt;a href=&quot;#&quot;&gt;更多&lt;/a&gt;</div><div class="line">       &lt;/span&gt;</div><div class="line">     &lt;/li&gt;</div><div class="line">  &lt;/ul&gt;</div><div class="line">  &lt;p&gt;速度与激情&lt;/p&gt;</div><div class="line">  &lt;p class=&quot;cur&quot;&gt;女人花&lt;/p&gt;</div><div class="line">  &lt;p&gt;欢乐颂&lt;/p&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;script&gt;</div><div class="line">var oLis = document.querySelectorAll(&apos;li&apos;),oPs = document.querySelectorAll(&apos;p&apos;);</div><div class="line"></div><div class="line">// 作用域方式一 利用不销毁作用域（弊端会形成多个不销毁作用域）</div><div class="line">   for(var i=0;i&lt;oLis.length;i++)&#123;</div><div class="line">       oLis[i].onclik = (function(n)&#123; //让li在外面接收 每一次自执行函数里返回的内部函数 导致当前自执行函数 形成的作用域 不能销毁</div><div class="line">       return function()&#123;</div><div class="line">          console.log(n);</div><div class="line">            for(var j = 0;j&lt;oLis.length;j++)&#123;</div><div class="line">               oLis[j].className = oPs[j].className =&apos;&apos;;</div><div class="line">            &#125;</div><div class="line">            this.className = oPs[n].className = &apos;cur&apos;;</div><div class="line">       &#125;</div><div class="line">       &#125;)(i);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   //作用域方式二 利用不销毁作用域 （弊端会形成多个不销毁作用域）</div><div class="line">   for (var i=0; i&lt;oLis.length;i++)&#123; //每一轮都会形成一个不销毁的作用域</div><div class="line">        (function(n)&#123;</div><div class="line">            oLis[n].onclick = function()&#123; //我们主动跑到里面来占用 在这里面定义的function 并把for循环的每一轮的值 传递进来 赋给每一个不销毁的作用域里的形参n来保存当前这一轮i的值</div><div class="line">               console.log(n);</div><div class="line">               for(var j=0;j&lt;oLis.length;j++)&#123;</div><div class="line">                   oLis[j].className =oPs[j].className =&apos;&apos;;</div><div class="line">               &#125;</div><div class="line">               this.className = oPs[n].className = &apos;cur&apos;;</div><div class="line">            &#125;</div><div class="line">        &#125;)(i);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   //自定义属性（推荐）</div><div class="line">   for(var i=0;i&lt;oLis.length;i++)&#123;</div><div class="line">       oLis[i].joo = i;</div><div class="line">       oLis[i].onclick = function()&#123;</div><div class="line">            for(var j=0;j&lt;oList.length;j++)&#123;</div><div class="line">                oLis[j].className=&apos;&apos;;</div><div class="line">                oPs[j].className =&apos;&apos;;</div><div class="line">            &#125;</div><div class="line">            this.className=&apos;cur&apos;;</div><div class="line">            oPs[this.joo].className = &apos;cur&apos;;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure></p>
<p><img src="/images/javascript/作用域选项卡.png"></p>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>JS中this当前行为主体</p>
<p>1、全局中的this是window</p>
<p><strong>主要研究函数的this</strong></p>
<p>2、函数执行的时候方法中的this要看函数执行的时候前面有没有‘.’,如果前面有点 点前面是谁this就是谁 如果没有点就是window</p>
<p>3、自执行函数里面的this永远就是window</p>
<p>4、给元素绑定事件 事件触发的时候 里面的this 就是当前绑定事件的元素</p>
<p>5、定时器中的this也是window</p>
<p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">//事件中的this</div><div class="line">var btn = document.getElementByTagName(&apos;button&apos;)[0];</div><div class="line">var oDiv = document.getElementByTagName(&apos;div&apos;)[0];</div><div class="line"></div><div class="line">btn.onclick = function()&#123;</div><div class="line">    console.log(this);//btn</div><div class="line">    ff();</div><div class="line">&#125;;</div><div class="line">funtion ff()&#123;</div><div class="line">     console.log(this);//window</div><div class="line">&#125;</div><div class="line"></div><div class="line">//自执行函数中的this</div><div class="line">(function()&#123;</div><div class="line">   console.log(this);//window</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">function fe()&#123;</div><div class="line">   console.log(this); //window</div><div class="line">   (function()&#123;</div><div class="line">       console.log(this);//window</div><div class="line">   &#125;)()</div><div class="line">&#125;</div><div class="line">fe();</div><div class="line"></div><div class="line">var obj = &#123;</div><div class="line">    fn:(function()&#123;</div><div class="line">        console.log(this);//obj window</div><div class="line">        return function()&#123;</div><div class="line">            console.log(this);//obj</div><div class="line">        &#125;</div><div class="line">    &#125;)()</div><div class="line">&#125;;</div><div class="line">obj.fn()</div><div class="line"></div><div class="line">//普通函数中的this</div><div class="line">var obj = &#123;&#125;;</div><div class="line">function fn()&#123;</div><div class="line">   console.log(this);//window</div><div class="line">   return function()&#123;</div><div class="line">       console.log(this);//window</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">var ff = fn();</div><div class="line">ff();</div><div class="line">obj.ff = ff;</div><div class="line">obj.ff(); //obj</div></pre></td></tr></table></figure></p>
<h2 id="类的封装"><a href="#类的封装" class="headerlink" title="类的封装"></a>类的封装</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><ul>
<li>单例模式：把描述同一事物（或同一对象）属性或方法放在一个内存空间，起到分组的作用</li>
<li>即使属性名相同也互不影响</li>
<li>“模块化开发”：项目中 开发模块比较多的时候，多人协作 每个人负责一个模块 最终将代码合在一起</li>
<li>单例模式中把flightFn和traninFn称为“命名空间”<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">//对象数据作用</div><div class="line">var flightFn = &#123;</div><div class="line">    title:&apos;我的机票&apos;,</div><div class="line">    mess:&apos;欢迎你来到我的机票购票&apos;,</div><div class="line">    say:function()&#123;</div><div class="line">        alert(&apos;这个模块是&apos;+this.title+&apos;,&apos;+this.mess);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">flightFn.say();</div><div class="line">var trainFn =&#123;</div><div class="line">    title:&apos;我的火车票&apos;，</div><div class="line">    mess:&apos;欢迎你来到我的火车票购票&apos;，</div><div class="line">    say:function()&#123;</div><div class="line">        alert(&apos;这个模块是&apos;+this.title+&apos;,&apos;+this.mess);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">trainFn.say();</div><div class="line"></div><div class="line">//公共模块</div><div class="line">var uitls = &#123;</div><div class="line">    date:function()&#123;</div><div class="line">         console.log(new Date);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var flightTicket1 =&#123;</div><div class="line">    fn:function()&#123;</div><div class="line">       console.log(&apos;这是关于机票&apos;);</div><div class="line">    &#125;,</div><div class="line">    init:function()&#123;</div><div class="line">    //    flightTicket1.fn();</div><div class="line">         this.fn();//调用自己模块中的功能</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">flightTicket1.init();</div><div class="line">var busTicket = &#123;</div><div class="line">    fn:function()&#123;</div><div class="line">       console.log(&apos;这是关于汽车票&apos;);</div><div class="line">       uitls.date();//调用其他模块的功能</div><div class="line">    &#125;,</div><div class="line">    init:function()&#123;</div><div class="line">        this.fn();//调用自己模块中的功能</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">busTicket.init();</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><ul>
<li>单例模式：手工作业</li>
<li>工厂模式： 把实现 相同功能的代码 放到一个函数里面 减少冗余代码 =&gt;”函数封装”</li>
<li>‘高内聚低耦合’：减少页面中重复代码 提高代码重复利用率<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function presonInfo(name,sex,hobby)&#123;</div><div class="line">   var obj = &#123;&#125;;</div><div class="line">   obj.name = name;</div><div class="line">   obj.sex = sex;</div><div class="line">   obj.hobby  = hobby;</div><div class="line">   obj.say = function()&#123;</div><div class="line">       consoel.log(this.name+&apos;是一个&apos;+this.sex+&apos;,我喜欢吃&apos;+this.hobby);</div><div class="line">   &#125;;</div><div class="line">   return obj;</div><div class="line">&#125;</div><div class="line">var obj1 = personInfo(&apos;chenhui&apos;,&apos;girl&apos;,&apos;火锅&apos;);</div><div class="line">console.log(obj1);</div><div class="line">obj1.say();</div><div class="line">var obj2 = presonInfo(&apos;qiuyue&apos;,&apos;girl&apos;,&apos;海底捞&apos;);</div><div class="line">console.log(obj2);</div><div class="line">obj2.say();</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><ul>
<li>在很多语言中都有面向对象</li>
<li>对象是一个泛指 比如 自然界</li>
<li>类：对对象的具体细分 比如 植物类 动物类 人类</li>
<li>实例：类中某一个具体事务 比如 人</li>
<li>类的 封装 继承 多态</li>
<li>继承：子类继承父类</li>
<li>多态：多种形态（重载和重写）JS中没有重载 但有些类似</li>
<li>重写：子类重写父类<blockquote>
<ul>
<li>OOP 面向对象编程（Object Oriented Programming，OOP，面向对象程序设计）是一种计算机编程架构。</li>
<li>编程语言 C、C++、Java、PHP、.NET(dot net)、C#、ASP、ASP.NET、Python、Ruby、Go、VB、JavaScript…  =&gt;所有的编程语言都是面向对象开发的(C是面向过程的)</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><ul>
<li><p>构造函数目的 创建一个自定义类 并且创建这个类的实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function CreatePerson(name,age)&#123;</div><div class="line">  //执行之前浏览器默认会创建一个对象</div><div class="line">     var num =815;</div><div class="line">     this.name = name;</div><div class="line">     this.age = age;</div><div class="line">   //默认将这个对象返回</div><div class="line">&#125;</div><div class="line">var person1 = new CreatePerson(&apos;chenhui&apos;,22);//构造函数模式 执行 它的返回值就是这个类的实例</div><div class="line">var person2 = new CreatePerson(&apos;qiuyue&apos;,21);</div><div class="line"> //person1和person2 都是CreatePerson的实例</div><div class="line">console.log(person1);</div><div class="line">console.log(person2.name);</div><div class="line">var person = CreatePerson(&apos;hui&apos;,20);//普通函数执行</div><div class="line">console.log(preson1);</div><div class="line"></div><div class="line">//在类中的this.xxx是给 当前实例添加属性 类中的this是当前实例</div></pre></td></tr></table></figure>
</li>
<li><p>类本身也是函数 类都是函数数据类型</p>
</li>
<li>实例是对象数据类型</li>
</ul>
<h4 id="工厂模式和构造函数模式区别"><a href="#工厂模式和构造函数模式区别" class="headerlink" title="工厂模式和构造函数模式区别"></a>工厂模式和构造函数模式区别</h4><p> 1、工厂模式 普通函数执行 构造函数通过new 来执行 默认创建一个对象 将其返回作为这个类的实例</p>
<p>2、执行的时候形成一个私有作用域 -&gt;形参赋值 -&gt;预解释 -&gt;代码 从上到下执行【同】</p>
<p>3、不同 构造函数模式执行的时候 会默认创建一个对象 也就是默认返回的实例     工厂模式 自己手动创建</p>
<p>4、构造函数模式执行的时候 如果指定返回的 是一个引用数据类型那么返回的就是引用数据类型</p>
<h4 id="单例模式和构造模式"><a href="#单例模式和构造模式" class="headerlink" title="单例模式和构造模式"></a>单例模式和构造模式</h4><p>1、单例模式是我们以后项目开发中业务逻辑编写最常用的设计模式：在业务逻辑相对复杂的时候，我们会基于单例模式引入“发布订阅模式”、“promise模式”…</p>
<p>2、构造原型模式是我们以后项目中封装类库、组件、插件、框架最常用的设计模式</p>
<p>3、单例模式：解决了变量冲突，实现了分类分组，在单例模式中我们的对象名叫做“命名空间”：单例模式把实现和描述同一事物的属性和方法进行分类归纳，然后汇总的同一命名空间下，不同的命名空间不冲突</p>
<p>4、真实项目中我们实现模块化开发基本都采用单例模式</p>
<p>5、高级单例模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var utils =&#123;</div><div class="line">    remove:function()&#123;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var skinRender =(function()&#123;</div><div class="line">    var a = 12;</div><div class="line">    return&#123;</div><div class="line">        fn:funcion()&#123;</div><div class="line">            utils.remove();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>1、每一个函数数据类型（普通函数、类（内置类、自定义类））都天生自带一个属性：prototype，这个属性的属性值是一个对象数据类型的结果  Person.prototype =&gt;{}</p>
<p>2、prototype对应的对象中，有一个天生自带的属性：constructor（构造函数），这个属性的属性值指向的是当前函数本身  Person.prototype =&gt;(constructor：Person)</p>
<p>3、每一个对象数据类型（普通对象、实例、prototype、函数也是对象）都是一个天生自带的属性：<strong>proto</strong>,这个属性指向自己所属类的原型（prototype）</p>
<p>4、类的原型（prototype）上存储的属性和方法都是实例公有的属性方法</p>
<blockquote>
<p>5、javascript就是一种基于原型的语言</p>
<p>6、原型链：ECMAScript的描述的原型链的概念，并将原型链作为实现继承的方法，其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。javascript原型链：</p>
</blockquote>
<p><img src="/images/javascript/原型链.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">function Preson(name)&#123;</div><div class="line">    //this.xxx = xxx 都是实例的私有属性</div><div class="line">    this.name = name;</div><div class="line">    this.say = function()&#123;</div><div class="line">        console.log(&apos;my name is&apos;+ this.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">var p1 = new Preson(&apos;卉&apos;);</div><div class="line">var p2 = new Preson(&apos;陈&apos;);</div><div class="line"></div><div class="line"></div><div class="line"> //原型上写的属性都是实例的公有属性</div><div class="line">Person.prototype.drink = function()&#123;</div><div class="line">       console.log(&apos;cheers!&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log(p1.say === p2.say);//-&gt;false</div><div class="line">console.log(p1.drink ===p2.drink);//-&gt;true</div><div class="line">//-&gt;hasOwnProperty:检测属性是否为对象（实例）的私有属性-&gt;true</div><div class="line">console.log(p1.hasOwnProperty(&apos;drink&apos;));</div><div class="line">//-&gt;in:不管当前的属性是私有的还是公有的，只要有返回的结果就是true</div><div class="line">console.log(&apos;drink&apos; in p1);//true</div><div class="line"></div><div class="line">p1.drink();//-&gt;先找自己私有属性，如果私有的属性中没有drink，则继续到所有类的原型上查找...一直找到Object.prototype为止 =&gt;这种查找的机制叫做“原型链”</div><div class="line"></div><div class="line">p1.__proto__.drink();//-&gt;跳过私有的查找，直接的找到原型上的公有属性</div><div class="line"></div><div class="line">p1.hasOwnProperty();//-&gt;this指向p1</div><div class="line"></div><div class="line">p1.__proto__.hasOwnProperty();//-&gt;this指向p1.__proto__(Person.prototype)</div><div class="line"></div><div class="line">p1.__proto__.__proto__.hasOwnProperty();//-&gt;this指向p1.__proto__.__proto__(Object.prortotype)   ===&gt;Object.prototype.hasOwnProperty()===&gt;让Object原型上的hasOwnProperty方法执行</div><div class="line">//通过以上三种办法，我们都可以把hasOwnProperty方法执行，但是有所区别：方法执行的时候，方法中的this是不一样的；在万恶的ie浏览器下，为了保护原型，屏蔽了我们使用__proto__这个属性</div></pre></td></tr></table></figure>
<h3 id="原型进阶"><a href="#原型进阶" class="headerlink" title="原型进阶"></a>原型进阶</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var ary = [13,24,27,56,89];</div><div class="line">var newAry = ary.sort(function(a,b)&#123;</div><div class="line">    return a - b;</div><div class="line">&#125;);</div><div class="line">// console.log(ary);//-&gt;会把原数组改变</div><div class="line">// console.log(newAry);//-&gt;也有返回值，返回的结果是改变后的数组</div><div class="line">newAry = newAry.slice(0,3);</div><div class="line">console.log(newAty);</div></pre></td></tr></table></figure>
<h3 id="原型进阶—链式写法"><a href="#原型进阶—链式写法" class="headerlink" title="原型进阶—链式写法"></a>原型进阶—链式写法</h3><p>链式写法：需要保证每一执行方法返回的结果依然是当前类的一个实例，这样就可以继续调取原型上的方法了…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var ary = [13,24,27,56,89];</div><div class="line">ary.sort(function(a,b)&#123;</div><div class="line">   return a - b;</div><div class="line">&#125;).slice(0,3).reverse().push(100).pop();//-&gt;Uncaught TypeError: ary.sort(...).slice(...).reverse(...).push(...).pop is not a function 执行push方法后，返回的结果是新增后数组的长度，是一个数字，不能再继续调取Array.prototype上的方法了</div><div class="line"></div><div class="line">Array.prototype.mySlice = function mySlice()&#123;</div><div class="line">     return this;//-&gt;实现链式写法最简单的方式，就是在每一个方法执行完成后返回this即可，因为方法找中的this就是当前类的实例</div><div class="line">&#125;;</div><div class="line">ary.mySlice().push();</div></pre></td></tr></table></figure>
<h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><blockquote>
<p>所有的对象数据类型（普通函数 实例 原型…）都是Object的一个实例</p>
</blockquote>
<ul>
<li>所有函数数据类型（普通函数 类（自定义 内置），都是Function这个类的实例）</li>
<li>所有实例都是对象数据类型的 函数也是对象数据类型的</li>
<li>对象数据类型都有一个天生自带的属性<strong>proto</strong>指向所属类的原型</li>
<li>因为 函数也是对象数据类型的 我们Function（内置类）它也是函数数据类型 所以它也是对象数据类型的 每一个对象数据类型都有一个天生自带的属性<strong>proto</strong>。</li>
<li>Function是一个内置类 类都是函数数据类型 所有函数数据类型 都是Function这个内置类的实例 所以Function作为一个类 一个 对象数据类型，它的<strong>proto</strong>指向所属类的原型 Function的prototype也就是Function自己的prototype</li>
<li>Object是一个基类 JS中最顶层的类，类都是函数数据类型函数也是对象数据类型函数 那么Object也有一个天生自带的属性<strong>proto</strong>,因为Object也是函数数据类型 它的<strong>proto</strong>指向Function的prototype</li>
</ul>
<h3 id="函数多面性"><a href="#函数多面性" class="headerlink" title="函数多面性"></a>函数多面性</h3><p>1、普通函数</p>
<p>执行的时候可以形成私有作用域，形参赋值 预解释 代码从上到下执行</p>
<p>2、作为一个类</p>
<p>具有原型链模式 类和实例的概念</p>
<p>3、作为一个普通对象</p>
<p>当做一个对象给它添加属性</p>
<h2 id="call-方法"><a href="#call-方法" class="headerlink" title="call 方法"></a>call 方法</h2><p>1、所有的函数数据类型（普通函数 类（内置 自定义））都是Function的一个实例</p>
<p>2、每一函数都可以使用Function的prototype上的存储的属性和方法</p>
<p>3、Function的prototype上 比较常用的（call/apply/bind(有兼容性)）方法</p>
<p>4、fn.call每一个函数都通过自己<strong>proto</strong>找到Function原型上的call方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">console.dir(Function);</div><div class="line">function fn()&#123;</div><div class="line">   console.log(this);</div><div class="line">&#125;</div><div class="line">console.log(fn.call === fn.__proto__.call);</div><div class="line">console.log(fn.call === Function.prototype.call);</div><div class="line">console.log(fn.__proto__.call === Function.prototype.call);</div><div class="line">fn.call();//fn();</div><div class="line">//fn.call(obj) 这里面fn是call的this，call方法让它的this执行也就是fn()并且将fn中的this修改为call的第一个参数值obj，所以 此时fn中的this被修改为obj</div></pre></td></tr></table></figure>
<h3 id="call的作用"><a href="#call的作用" class="headerlink" title="call的作用"></a>call的作用</h3><p>1、让call方法中的this 当做一个函数执行【改变call‘.’前面方法中的this，并让前面的方法执行】</p>
<p>2、将call的this中的this修改为call的第一个参数值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;info:&apos;say&apos;&#125;;</div><div class="line">var info = &apos;sayHi&apos;;</div><div class="line">function fn()&#123;//因为fn是call方法的this call将fn中this修改为了第一个参数值obj this-&gt;obj</div><div class="line">   console.log(this.info);//obj.info</div><div class="line">&#125;</div><div class="line">fn.call(obj);//call中this -&gt;fn()-&gt; 将fn中的this 修改为call(obj)call中第一参数值obj</div><div class="line">fn();//如果这样执行 fn中的this是window</div></pre></td></tr></table></figure>
<h3 id="call语法"><a href="#call语法" class="headerlink" title="call语法"></a>call语法</h3><p>函数.call([this],param1,param2…) 第一个参数作为call的this中this 其余后面依次是在给call的this里面传递的参数值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;info:&apos;say&apos;&#125;;</div><div class="line">function fn(a,b)&#123;</div><div class="line">     console.log(this);//Object</div><div class="line">     console.log(a,b);//10,20</div><div class="line">&#125;</div><div class="line">fn.call(obj,10,20);</div></pre></td></tr></table></figure></p>
<h3 id="严格模式或非严格模式下的call"><a href="#严格模式或非严格模式下的call" class="headerlink" title="严格模式或非严格模式下的call"></a>严格模式或非严格模式下的call</h3><p>‘use strict’</p>
<p>‘严格模式’让Javascript在更加严格的方式下运行</p>
<p>call作用 就是改变方法中的this关键字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var arr = [1,2,3];</div><div class="line">function fn()&#123;</div><div class="line">   console.log(this);</div><div class="line">&#125;</div><div class="line">fn.call();</div><div class="line">fn.call(null);</div><div class="line">fn.call(undefined);</div><div class="line">fn.call(arr);</div></pre></td></tr></table></figure></p>
<p>非严格模式 如果call中第一个参数不传或者传的是null/undefined,方法中this都是window，其余的call中第一个参数是啥就是啥</p>
<p>在严格模式下 如果call中第一参数不传就是undefined，其余的call中第一个参数就是啥就是啥 如果是null就是null，如果是undefined就是undefined</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function fn(a,b)&#123;</div><div class="line">console.log(this);</div><div class="line">console.log(a,b);</div><div class="line">&#125;</div><div class="line">fn.call(null,100,200);//this是 number 100 把200当做第一个实参 传递给 fn中的第一个形参</div></pre></td></tr></table></figure>
<blockquote>
<p>call 还可以实现继承</p>
<h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><p>apply 修改方法中的this关键字</p>
</blockquote>
<p>作用：将apply ‘.’前面的this修改call中的第一个参数值，并让apply‘.’前面的this执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var arr1 = [1,2,3];</div><div class="line">var arr2 = [3,4,5];</div><div class="line">function fn(a,b)&#123;</div><div class="line">   console.log(this);</div><div class="line">   console.log(a,b);</div><div class="line">&#125;</div><div class="line">fn.call(arr1,100,200);</div><div class="line">fn.apply(arr2);//首先fn是apply的this 将fn中的this改为arr2并让 fn执行</div><div class="line">fn.apply(arr1,[100,200]);</div></pre></td></tr></table></figure></p>
<h3 id="call和apply的区别"><a href="#call和apply的区别" class="headerlink" title="call和apply的区别"></a>call和apply的区别</h3><p>首先call和apply都是改变方法中的this关键字</p>
<p>区别：call传参的时候是从第二参数开始一个一个的传递</p>
<pre><code>apply把需要传递的参数值 放在一个数组里，也相当于一个一个将参数传递进去
</code></pre><h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><p>当参数明确是可以用call，当参数不明确是可用apply结合arguments<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">print.call(window,&quot;背&quot;,&quot;光&quot;,&quot;脚&quot;,&quot;本&quot;);</div><div class="line">//foo参数可能多个</div><div class="line">function foo()&#123;</div><div class="line">print.apply(window,arguments);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="bind-IE-6-8"><a href="#bind-IE-6-8" class="headerlink" title="bind (IE 6-8)"></a>bind (IE 6-8)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">var fe = fn.bind(arr1);</div><div class="line">//预处理：事先将fn中的this修改为arr1 但并不会让fn执行，而是将改造后的fn当做返回值返回</div><div class="line">//用的时候在执行</div><div class="line">var arr1 = [1,2,3];</div><div class="line">var arr2 = [3,4,5];</div><div class="line">function fn(a,b)&#123;</div><div class="line">   console.log(this);</div><div class="line">   console.log(a,b);</div><div class="line">&#125;</div><div class="line">// fn.call(arr1);</div><div class="line">var fe = fn.bind(arr1,100,200);//fe接收的是this被改造后的fn</div><div class="line">fe();//改造后的fn执行</div><div class="line">   //call/apply第一个参数指定谁方法中this是谁</div><div class="line"></div><div class="line"></div><div class="line">function fn1()&#123;</div><div class="line">   console.log(&apos;fn1&apos;);</div><div class="line">&#125;</div><div class="line">function fn2()&#123;</div><div class="line">   console.log(&apos;fn2&apos;);</div><div class="line">&#125;</div><div class="line">window.fn1.call(fn2);//让fn1执行将里面this修改为fn2</div><div class="line">//call‘.’前面的方法执行</div><div class="line">//然后让‘.’前面的方法里面的this 改为call中第一个参数 fn2</div><div class="line">fn1.call.call.call.call()每一个函数都可以使用Function.prototype上的call方法 因为call也是要给函数 所以就可以fn1.call.call.call.call</div><div class="line">fn1.call(fn2);//fn1()把里面this变为fn2</div><div class="line">fn1.call.call(fn2);</div></pre></td></tr></table></figure>
<h3 id="多个call"><a href="#多个call" class="headerlink" title="多个call"></a>多个call</h3><p>规律：两个call以上最终执行的是 最后一个call中的第一个参数  里面this是window<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">var obj =&#123;</div><div class="line">     fn: function()&#123;</div><div class="line">         console.log(this);//fn2</div><div class="line">         console.log(&apos;fn&apos;);</div><div class="line">     &#125;</div><div class="line">&#125;;</div><div class="line">// obj.fn.call(fn2);//让obj.fn执行 并且将里面的this改为 fn2 obj.fn =&gt; fn2.fn()</div><div class="line">function fn1()&#123;</div><div class="line">    console.log(&apos;fn1&apos;);</div><div class="line">&#125;</div><div class="line">function fn2()&#123;</div><div class="line">    console.log(&apos;fn2&apos;);</div><div class="line">&#125;</div><div class="line">//  fn1.call.call(fn2);</div><div class="line">    fn1.call.call.call.call(fn2);</div><div class="line">    //让fn1.call执行 将第一个call前面的fn1变成了fn2  fn1.call()变成了fn2.call()</div><div class="line">    //并且让fn2.call()执行 让fn2执行 里面this默认为window</div><div class="line">    //最终执行的就是我们fn2() 然后输出‘fn2’</div><div class="line"></div><div class="line">    //最后一个call先执行 最后一个call的目的 让fn1.call执行 并且将里面的this改为 fn2 相当于 fn1.call() =&gt; fn2.call()</div><div class="line">    //fn2.call()让fn2执行并且将里面的this改成window</div><div class="line">    //最终fn2执行输出‘fn2’；</div></pre></td></tr></table></figure></p>
<h2 id="try-catch-js中比较常用的捕获异常方法"><a href="#try-catch-js中比较常用的捕获异常方法" class="headerlink" title="try catch js中比较常用的捕获异常方法"></a>try catch js中比较常用的捕获异常方法</h2><p>try catch finally</p>
<p>如果try里面报错就执行catch里面的代码</p>
<p>catch(e).message 报错信息</p>
<p>finally不管上面报不报错 都会执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">try&#123;</div><div class="line">   console.log(num);</div><div class="line">&#125;catch(e)&#123;</div><div class="line">   console.log(e.message);</div><div class="line">   //throw new Error(e.message);//让浏览器抛出异常</div><div class="line">&#125;</div><div class="line">console.log(123);</div></pre></td></tr></table></figure>
<h2 id="arguments是一个类数组-但是也可以像数组一样可以循环遍历"><a href="#arguments是一个类数组-但是也可以像数组一样可以循环遍历" class="headerlink" title="arguments是一个类数组 但是也可以像数组一样可以循环遍历"></a>arguments是一个类数组 但是也可以像数组一样可以循环遍历</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">//利用数组中的slice方法将类数组转化为数组，只需要改变slice中this即可</div><div class="line">Array.prototype.slice.call(arguments,0)</div><div class="line">[].slice.call(arguments,0)</div><div class="line"></div><div class="line">//求平均数</div><div class="line">// arguments 实参集合 类数组 它也不是数组 不是Array的实例所以不能直接使用 数组sort的方法</div><div class="line">function average()&#123;</div><div class="line">    var arr =[].slice.call(arguemnts,0);//让slice方法中操作的this指向我们的arguments</div><div class="line">    arr.sort(function(a,b)&#123;</div><div class="line">        return a-b;</div><div class="line">    &#125;);//排序</div><div class="line">    arr.shift();//shift 删除数组开头第一项 返回的删除的内容 原数组改变</div><div class="line">    arr.length--;</div><div class="line">    var sum = eval(arr.join(&apos;+&apos;));</div><div class="line">    var num = (sum/arr.length).toFixed(2);</div><div class="line">    return num;</div><div class="line">&#125;</div><div class="line">var argNum = average(9,2,8,9,10,7,6);</div><div class="line">cosole.log(argNum);</div><div class="line"></div><div class="line">//用slice将类数组转化为数组时 由于DOM元素集合在Ie6-8中不兼容 所以我们不能用</div><div class="line">//js中如果当前代码报错 不处理的情况下 后面代码不会执行</div><div class="line">//利用异常捕获方法</div><div class="line">var lis = document.getElementByTagName(&apos;li&apos;);//获取所有li</div><div class="line">//类数组为数组</div><div class="line">function listToArray(list)&#123;</div><div class="line">    try&#123;</div><div class="line">        return [].slice.call(list,0)</div><div class="line">    &#125;catch (e)&#123;</div><div class="line">        var arr = [];</div><div class="line">        for(var i=0; i&lt;list.length;i++)&#123;</div><div class="line">               arr.push(list[i]);</div><div class="line">        &#125;</div><div class="line">        return arr;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">console.log(listToArray(lis));</div></pre></td></tr></table></figure>
<h2 id="求数组中最大值和最小值"><a href="#求数组中最大值和最小值" class="headerlink" title="求数组中最大值和最小值"></a>求数组中最大值和最小值</h2><p>1、利用排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var arr = [10,20,11,12,9,15];</div><div class="line">//先排序 从小到大 取出第一项（min）和最后一项（max）</div><div class="line">arr.sort(function(a,b)&#123;</div><div class="line">       return a - b;</div><div class="line">&#125;);</div><div class="line">console.log(arr);</div><div class="line">var max = arr[arr.length - 1];</div><div class="line">var min = arr[0];</div></pre></td></tr></table></figure></p>
<p>2、假设法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//先取出第一项作为基准点 假设第一项是最大 然后用数组剩余项分别和这个基准点进行比较，如果数组中当前项 比我这个基准点还要大，我们就让当前项在做为我们的基准点 一直比较下去</div><div class="line">var arr = [10,20,11,12,9,15];</div><div class="line">var max = arr[0]; //假设数组中第一项是最大的</div><div class="line">var min = arr[0];</div><div class="line">for(var i = 1;i&lt;arr.length;i++)&#123; //拿出数组中剩余的每一项和max进行比较</div><div class="line">        var cur = arr[i];</div><div class="line">        // 20 &gt; 10? max = 20 : null;</div><div class="line">        cur &gt; max ? max = cur : null;//谁大就让max等于谁</div><div class="line">        cur &lt; min ? min = cur : null;//谁下就让max等于谁</div><div class="line">&#125;</div><div class="line">console.log(max,min);// 20 9</div></pre></td></tr></table></figure></p>
<p>3、Math.min/Math.max 比较一堆数中的最小值和最大值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var min = Math.min(10,20,11,12,9,15);</div><div class="line">var max = Math.max(10,20,11,12,9,15);</div><div class="line">var min = Math.min([10,20,11,12,9,15]);</div><div class="line">var max = Math.max([10,20,11,12,9,15]);</div></pre></td></tr></table></figure></p>
<p>4、利用apply传递参数的时候 是把需要的参数放在数组里 其实也上相当于一次性分别把数组中的每一个参数取出来 当作实参传递到我们方法中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var arr =[10,20,11,12,9,15];</div><div class="line">// var max = Math.max(eval(arr.toSting()));</div><div class="line">//利用Math的方法取出最大值</div><div class="line">var max =Math.max.apply(null,[10,20,11,12,9,15])</div><div class="line">var min =Math.min.apply(null,[10,20,11,12,9,15])</div><div class="line">console.log(max.min);</div></pre></td></tr></table></figure></p>
<h2 id="DOM映射"><a href="#DOM映射" class="headerlink" title="DOM映射"></a>DOM映射</h2><p>DOM映射：html页面中的元素 和 JS中通过DOM方法获取的元素对象 是绑定在一起的 一一对应的   一个改变另一个也会改变</p>
<p>HTMLCollection/NodeList: 元素集合/节点集合 即时更新，如果所属的内部结构发生了改变 它会自动同步更新<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">&lt;ul&gt;</div><div class="line">  &lt;li&gt;111&lt;/li&gt;</div><div class="line">  &lt;li&gt;222&lt;/li&gt;</div><div class="line">  &lt;li&gt;333&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div><div class="line">&lt;script&gt;</div><div class="line">var uls = document.getElementByTagName(&apos;ul&apos;)[0];</div><div class="line">var lis = uls.getElementByTagName(&apos;li&apos;);</div><div class="line">lis[1].style.backgroundColor = &apos;red&apos;;</div><div class="line">setTimeout(function()&#123;</div><div class="line">//uls.appendChild(lis[1]);//本身页面中已有的 在appendChild 等于 移动元素到容器末尾</div><div class="line">var list = document.creatElement(&apos;li&apos;);</div><div class="line">// list.innerHTML = &apos;hello&apos;;</div><div class="line">// uls.appendChild(lis[1]);//本身页面中已有的 在appendChild 等于移动元素到容器末尾</div><div class="line">        var list = document.createElement(&apos;li&apos;);</div><div class="line">        //list.innerHTML = &apos;hello&apos;;</div><div class="line">        //uls.appendChild(list);</div><div class="line">        uls.insertBefore(lis[2],lis[0]);</div><div class="line">&#125;,2000);</div><div class="line"> //HTMLCollection: 元素集合 即使更新 如果内部结构发生改变 会更新同步元素集合中</div><div class="line"> console.log(lis);</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure></p>
<p>DOM回流：页面中html结构发生改变（增加、删除、位置改变），浏览器就会重新计算一次DOM结构</p>
<p>动态创建 多次操作DOM(appendChild)就会引起多次回流 耗费性能</p>
<p>字符串拼接是把所有拼接好的 最终一次输出到页面，只引发一次回流</p>
<p>重绘：页面中部分样式发生改变(背景颜色，字体颜色)，浏览器只会把这个改变的元素重新渲染</p>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>JSON:一种数据格式，主要应用于后端交互，前台向后台发送请求时 后台返回的基本是JSON格式的数据<br>JSON对象 JSON字符串</p>
<p>1、JSON对象 和js对象类似 但是属性名必须用’””‘包起来，属性值如果是字符串也要双引号包起来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var obj1 = &#123;name: &apos;chenhui&apos;, &quot;age&quot;: 22&#125;; // 普通JS对象</div><div class="line">var obj2 = &#123;&quot;name&quot;: &quot;chenhui&quot;, &quot;age&quot;: 22&#125;; // JSON对象</div><div class="line">var arr = [</div><div class="line">        &#123;&quot;name&quot;: &quot;chenhui&quot;, &quot;age&quot;: 22&#125;,</div><div class="line">        &#123;&quot;name&quot;: &quot;chenhui&quot;, &quot;age&quot;: 22&#125;,</div><div class="line">        &#123;&quot;name&quot;: &quot;chenhui&quot;, &quot;age&quot;: 22&#125;</div><div class="line">    ];</div></pre></td></tr></table></figure></p>
<p>2、JSON字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var jsonStr1 = &apos;&#123;&quot;name&quot;: &quot;chenhui&quot;, &quot;age&quot;: 22&#125;&apos;;</div><div class="line">var jsonStr2 = &apos;[&#123;&quot;name&quot;: &quot;chenhui&quot;, &quot;age&quot;: 22&#125;]&apos;;</div></pre></td></tr></table></figure></p>
<p>3、window浏览器对象上有一个JSON属性对象</p>
<p>提供了两个方法：</p>
<p>(1)、JSON.parse：用来将JSON格式的字符串转化为JSON格式对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var jStr1 = JSON.parse(jsonStr1);</div><div class="line">var jStr2 = JSON.parse(jsonStr2);</div><div class="line">console.log(jsonStr2);</div><div class="line">JSON.parse(&apos;&#123;&quot;name&quot;:&quot;chenhui&quot;,&quot;age&quot;:22&#125;&apos;);</div><div class="line">JSON.parse(&apos;[&#123;&quot;name&quot;:&quot;chenhui&quot;,&quot;age&quot;:22&#125;]&apos;);</div><div class="line">JSON.parse(&apos;[&#123;&quot;name&quot;:&quot;chenhui&quot;,&quot;info&quot;:&quot;web前端工程师&quot;&#125;]&apos;);</div></pre></td></tr></table></figure></p>
<p>(2)、JSON.stringify: 将普通格式对象/JSON格式的对象转换为JSON格式字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var objs = &#123;name: &apos;chenhui&apos;, info: &apos;web前端工程师&apos;&#125;;</div><div class="line">var jObj = &#123;&quot;name&quot;: &quot;chenhui&quot;, &quot;info&quot;: &quot;web前Duang工程师&quot;&#125;;</div><div class="line">var Obj1 = JSON.stringify(objs);</div><div class="line">var Obj2 = JSON.stringify(jObj);</div><div class="line">JSON.stringify(&#123;&quot;name&quot;: &quot;chenhui&quot;, &quot;info&quot;: &quot;web前端工程师&quot;&#125;);</div><div class="line">JSON.stringify(&#123;name: &apos;chenhui&apos;, info: &apos;web前端工程师&apos;&#125;);</div><div class="line">console.log(Obj1);</div><div class="line">console.log(typeof Obj1);</div><div class="line">console.log(Obj2);</div><div class="line">console.log(typeof Obj2);</div></pre></td></tr></table></figure></p>
<p>(3)、JSON在ie7以下 不兼容 就需要使用eval<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">eval(&apos;(&#123;&quot;name&quot;: &quot;chenhui&quot;,&quot;age&quot;: 22&#125;)&apos;);</div><div class="line">var json1 = &apos;&#123;&quot;name&quot;: &quot;chenhui&quot;,&quot;age&quot;: 22&#125;&apos;;</div><div class="line">var data = eval(&apos;(&apos; + json1 + &apos;)&apos;);</div><div class="line">console.log(data);</div></pre></td></tr></table></figure></p>
<p>(4)、处理兼容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var json1 = &apos;&#123;&quot;name&quot;: &quot;chenhui&quot;,&quot;age&quot;: 10&#125;&apos;;</div><div class="line">    &quot;JSON&quot; in window ? JSON.parse(json1) : eval(&apos;(&apos; + json1 + &apos;)&apos;);</div></pre></td></tr></table></figure></p>
<blockquote>
<p>eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。该方法只接受原始字符串作为参数，如果 string 参数不是原始字符串，那么该方法将不作任何改变地返回。因此请不要为 eval() 函数传递 String 对象来作为参数。</p>
</blockquote>
<h2 id="字符串拼接和动态创建【dom节点或dom元素】"><a href="#字符串拼接和动态创建【dom节点或dom元素】" class="headerlink" title="字符串拼接和动态创建【dom节点或dom元素】"></a>字符串拼接和动态创建【dom节点或dom元素】</h2><ul>
<li><p>动态添加<br> 文档碎片 动态创建的一个容器 通常用来避免多次回流</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//创建文档碎片</div><div class="line">var frg = document.createDocumentFragment()</div></pre></td></tr></table></figure>
<ul>
<li>优点 不会影响原有的 事件和效果</li>
<li>缺点 引发多次回流</li>
</ul>
</li>
<li>字符串添加拼接<ul>
<li>优势：只会引发一次回流</li>
<li>弊端：当我们在往原有的里面拼接添加的时候 相当于想把原有的当做字符串获取到然后再和新生成拼接成字符串 在输出，这样浏览器会重新渲染和解析 从而导致原有的事件和效果失效</li>
</ul>
</li>
</ul>
<h2 id="ajax数据【简单交互】"><a href="#ajax数据【简单交互】" class="headerlink" title="ajax数据【简单交互】"></a>ajax数据【简单交互】</h2><p>ajax = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</p>
<p>ajax:异步请求 局部刷新【ajax的最大特点】</p>
<p>优点：通过AJAX，JavaScript 无需等待服务器的响应，而是：</p>
<ul>
<li>在等待服务器响应时执行其他脚本</li>
<li>当响应就绪后对响应进行处理</li>
</ul>
<p>1、创建 XMLHttpRequest 对象（IE5 和 IE6 使用 ActiveXObject）</p>
<ul>
<li>XMLHttpRequest 对象用于和服务器交换数据。</li>
</ul>
<p>2、（1）、要发送请求</p>
<ul>
<li><p>@param1 获取方式（method）请求方式 get post<br>get与post相比，get更简单也更快，并且大部分情况下都能用<br>以下情况中，使用用post请求</p>
<ul>
<li>无法使用缓存文件（更新服务器上的文件或数据库）</li>
<li>向服务器发送大量数据（POST没有数据量限制）</li>
<li>发送包含未知字符的用户输入时，POST比GET更稳定也更可靠</li>
</ul>
</li>
<li><p>@param2 请求地址（url） ‘./data.txt’</p>
</li>
<li><p>@param3:（async） true 默认就是异步请求  false 同步</p>
<p>（2）、监听请求响应（还需要判断是否请求成功 是否拿到数据）</p>
<p>onreadystatechange 事件<br>当请求被发送到服务器时，我们需要执行一些基于响应的任务。</p>
<p>每当readyState改变时，就会触发onreadysatechange事件。</p>
<p>readyState属性存有XMLHttpRequest的状态信息。XMLHttpRequest对象的三个重要的属性：</p>
<p>onreadystatechange 存储函数（或函数名），每当readyState属性改变时，就会调用该函数。</p>
</li>
<li><p>readyState: 0,1,2,3,4    ajax 状态码</p>
<ul>
<li>0：请求未初识化</li>
<li>1：服务器连接已建立</li>
<li>2：请求已接收</li>
<li>3：请求处理中</li>
<li>4：请求已完成，且响应已就绪</li>
</ul>
</li>
<li>status http请求状态码<ul>
<li>200：”OK”</li>
<li>404：未找到页面<br>3、发送 send()<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var xhr = new XMLHttpRequest;//生成一个XMLHttpRequest的实例 在这个实例里面提供了发送请求和接收数据的 属性方法</div><div class="line">console.log(xhr);</div><div class="line">xhr.open(&apos;get&apos;,&apos;./data.txt&apos;,true);</div><div class="line">xhr.onreadystatechange = function()&#123;</div><div class="line">//如果是4的话说明成功完成发送请求 如果http请求成功状态码基本是200 一些2开头三位数也代表成功；通常访问一个不存在的网页返回的http状态码 404</div><div class="line">     if(this.readyState === 4&amp;&amp; this.status == 200)&#123;</div><div class="line">        console.log(xhr.responseText);</div><div class="line">        console.log(typeof xhr.responseText);</div><div class="line">     &#125;</div><div class="line">&#125;;</div><div class="line">//发送</div><div class="line">xhr.send();</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>可以使用Callback【回调】函数</p>
</blockquote>
<p>callback 函数是一种以参数形式传递给另一个函数【ajax请求总共有多少种callback】</p>
<h3 id="ajax-可以用来与XML文件进行交互通信【高级】"><a href="#ajax-可以用来与XML文件进行交互通信【高级】" class="headerlink" title="ajax 可以用来与XML文件进行交互通信【高级】"></a>ajax 可以用来与XML文件进行交互通信【高级】</h3><p>loadXMLDoc() 函数创建 XMLHttpRequest 对象，添加当服务器响应就绪时执行的函数，并将请求发送到服务器。</p>
<p>当服务器响应就绪时，会构建一个 HTML 表格，从 XML 文件中提取节点（元素），最后使用已经填充了 XML 数据的 HTML 表格来更新 txtCDInfo 占位符</p>
<p>responseXML    获得 XML 形式的响应数据。</p>
<p>通过XMLHTTP加载XML文件</p>
<p><img src="/images/javascript/简单交互过程.png"></p>
<h2 id="正则-regular-expression"><a href="#正则-regular-expression" class="headerlink" title="正则(regular expression)"></a>正则(regular expression)</h2><p>正则表达式是用来处理字符串的，它的特长在于处理复杂的字符串</p>
<p>1、正则定义了一个字符串的模型</p>
<p>2、正则的第一个作用是“验证某字符串是否和这个模型相匹配”。</p>
<p>3、正则的第二作用是“把匹配到的内容找出来”</p>
<p>正则就是由相关‘元字符’和‘修饰符’组成的一个规则，用来匹配、验证或捕获字符串中某些内容的规则（正则仅仅是用来处理字符串的）</p>
<blockquote>
<ul>
<li>元字符</li>
<li>修饰符</li>
<li>编写常用的正则</li>
<li>正则的验证</li>
<li>正则的捕获</li>
<li>正则的方法的封装</li>
</ul>
</blockquote>
<h3 id="定义正则"><a href="#定义正则" class="headerlink" title="定义正则"></a>定义正则</h3><p>1、创建正则的两种方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var reg = /abcd/;  //对象直接量方法</div><div class="line">var reg = new RegExp(&apos;abcd&apos;)  //这个叫构造函数方式</div></pre></td></tr></table></figure></p>
<p>2、如果有模式修正符，比如上全文查找abcd这个字符串，两种写法分别是(g是模式修正符，表示在整个字符串里面多次查找)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var  reg = /abcd/g;</div><div class="line">var reg = newu RegExp(&apos;abcd&apos;,&apos;g&apos;);</div></pre></td></tr></table></figure></p>
<p>3、有一种情况要注意，就是如果正则中出现了斜杠“\”(回车上边的斜杠)，在用构造函数创建正则对象时，要转义，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">reg = new RegExp(&quot;\\w+&quot;) //这里的\要转义</div><div class="line">reg = /\w+/   //这样就不需要</div></pre></td></tr></table></figure></p>
<h3 id="正则的元字符"><a href="#正则的元字符" class="headerlink" title="正则的元字符"></a>正则的元字符</h3><blockquote>
<p>只要在“/元子符/”之间包含起来的，都是正则的元字符</p>
</blockquote>
<ul>
<li>特殊元子符<ul>
<li>\ 转义字符（把有意义和没意义的字符来回转）</li>
<li>.除了\n以外的任意字符</li>
<li>\n 换行符</li>
<li>^ 以xxx开始</li>
<li>$ 以xxx结束</li>
<li>\d 匹配0-9之间的任意数字 \D：除了0-9之间数字的任意字符</li>
<li>\b 匹配一个边界</li>
<li>\w 匹配数字、字母、下划线中的任意字符。等价于’[A-Za-z0-9]’。\W 匹配包括下划线</li>
<li>\s 匹配一个空白字符</li>
<li>[xyz] x或者y或者z中的一个，例如：[abcd]四个字母中的任意一个</li>
<li>[^xyz] 除了三个以外的任意字符</li>
<li>[a-z] 匹配a-z中的任意字符</li>
<li>[^a-z] 匹配除了a-z中的任意字符</li>
<li>x|y 匹配x或者y中的任意一个</li>
<li>() 分组</li>
<li>?: 只匹配不捕获</li>
<li>?= 正向预查</li>
<li>?! 负向预查 两个预查也起到了只匹配不捕获的作用</li>
<li>…</li>
</ul>
</li>
<li>量词元字符<ul>
<li>* 出现零次或者多次</li>
<li>？ 出现零次或者一次</li>
<li>+ 出现一次或者多次</li>
<li>{n} 出现n次</li>
<li>{n,} 出现n到多次</li>
<li>{n,m} 出现n到m次</li>
</ul>
</li>
<li>普通云字符：代表本身意思的元字符</li>
</ul>
<h3 id="正则的修饰符（img）"><a href="#正则的修饰符（img）" class="headerlink" title="正则的修饰符（img）"></a>正则的修饰符（img）</h3><ul>
<li>i: ignoreCase 忽略大小写</li>
<li>m: multiline 匹配换行</li>
<li>g: global 全局匹配</li>
</ul>
<h3 id="test-正则的方法，验证某一个字符串是否符合某一个规则的"><a href="#test-正则的方法，验证某一个字符串是否符合某一个规则的" class="headerlink" title="test 正则的方法，验证某一个字符串是否符合某一个规则的"></a>test 正则的方法，验证某一个字符串是否符合某一个规则的</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">var str =&apos;chenhui1995qiuyue2017&apos;;</div><div class="line">var reg = /\d+/; //-&gt;只要“包含连续出现一个多个数字”这个规则就可以</div><div class="line">console.log(reg.test(str));//-&gt;TRUE</div><div class="line">reg = /^\d+$/; //-&gt;以数字开头，以数字结尾，中间是数字（只能是数字）</div><div class="line">console.log(reg.test(str)); //-&gt;FALSE</div><div class="line"></div><div class="line">//表单验证： 验证用户输入的内容是否既定的格式（常用的正则）</div><div class="line"></div><div class="line">//1、手机号  11位数字 以1开头</div><div class="line">var reg =  /^1\d&#123;10&#125;$/;</div><div class="line"></div><div class="line">//2、身份证  18位（前17位是数字，最后一位是数字或者X）；前六位：省市县；第七位到第十四位是出生年月日；最后四位是随机码，倒数第二位代表性别 奇数男 偶数女</div><div class="line">var str  = &apos;130424199712190017&apos;;</div><div class="line">var reg = /^(\d&#123;6&#125;)(\d&#123;4&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)\d&#123;2&#125;(\d)(?:\d|X)$/;</div><div class="line">console.log(str.match(reg));//-&gt;match:字符串的方法，捕获到正则匹配的结果，只要加上分组，在捕获的时候不仅把大正则匹配的捕获到，而且里面的每一个小分组（小正则）匹配的也可以单独的捕获到，如果其中有某一个分组不需要捕获（仅仅是改变优先级方便匹配），我们在分组的前面叫“？:”=&gt;只匹配不捕获</div><div class="line">[&quot;130424199712190017&quot;,&quot;130424&quot;,&quot;1997&quot;,&quot;12&quot;,&quot;19&quot;,&quot;1&quot;...]</div><div class="line"></div><div class="line">//3、验证是否为有效的数字  整数或者负数：可以以+或者-开头，再或者没有任何的符号开头；整数或者小数（如果是小数的话，必须要有点，点后面必须有数字才可以）；整数部分： 不能以0开头</div><div class="line">var reg =/^[+-]？(\d|([1-9]\d+))(\.\d+)?$/;</div><div class="line">//-&gt;([1-9]\d+)多位数不能以0开头A</div><div class="line">//-&gt;(\d\A) 一位数或者多位数 =&gt;整数</div><div class="line">//-&gt;()? 整个小数部分出现零到一次</div><div class="line"></div><div class="line">reg =/^(\+\-)?(\d\([1-9]\d+))(\.\d+)?$/;</div><div class="line">//-&gt;如何区分是第几个分组：按照小括号做半部分从左到右数即可（不分层级），数的过程中跳过?:、?=、?!，因为他们只匹配不捕获</div><div class="line"></div><div class="line">//4、验证是否为中文姓名 中文汉字 二到四位</div><div class="line">var reg =/^[\u4e00-\u9fa5]&#123;2,4&#125;$/;</div></pre></td></tr></table></figure>
<hr>
<h1 id="javascript-基本算法：排序，代码书写"><a href="#javascript-基本算法：排序，代码书写" class="headerlink" title="javascript 基本算法：排序，代码书写"></a>javascript 基本算法：排序，代码书写</h1><h2 id="javascript基础知识结构"><a href="#javascript基础知识结构" class="headerlink" title="javascript基础知识结构"></a>javascript基础知识结构</h2><ul>
<li><p>javascript –基础知识</p>
<ul>
<li><p>数据类型</p>
<ul>
<li><p>基本数据类型</p>
</li>
<li><p>引用数据类型</p>
<ul>
<li><p>声明对象用var</p>
</li>
<li><p>函数function</p>
<ul>
<li><p>函数的格式</p>
</li>
<li><p>形参、实参</p>
</li>
<li><p>return</p>
</li>
<li><p>arguments、callee</p>
</li>
<li><p>匿名函数</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>BOM</p>
</li>
<li><p>DOM</p>
</li>
<li><p>判断</p>
<ul>
<li><p>if else</p>
</li>
<li><p>switch case</p>
</li>
<li><p>三元运算</p>
</li>
<li><p>||和&amp;&amp;</p>
</li>
</ul>
</li>
<li><p>循环</p>
<ul>
<li><p>for</p>
</li>
<li><p>for in</p>
</li>
<li><p>while 循环</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="1、九九乘法表"><a href="#1、九九乘法表" class="headerlink" title="1、九九乘法表"></a>1、九九乘法表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;script&gt;</div><div class="line">    var str=&apos;&apos;;</div><div class="line">    for (var i=1;i&lt;=9;i++)&#123;</div><div class="line">        str+=&apos;&lt;p&gt;&apos;;</div><div class="line">        // 当i=1的时候 p标签中需要一对span</div><div class="line">        // 当i=2的时候 p标签中需要两对span</div><div class="line">        // 当i=3的时候 p标签中需要三对span</div><div class="line">        //当i=1 生成一对p标签  j&lt;=1 里面的循环只执行一次 生成一对span i=2</div><div class="line">        //当i=2 生成一对p标签  j&lt;=2 里面的循环只执行2次 生成两对span i=3</div><div class="line">        //当i=9 生成一对p标签  j&lt;=9 里面的循环只执行9次 生成9对span i=10</div><div class="line">        for (var j=1;j&lt;=i;j++)&#123;</div><div class="line">            str+=&apos;&lt;span&gt;&apos;;</div><div class="line">            str+=j+&apos;*&apos;+i+&apos;=&apos;+(i*j);</div><div class="line">            str+=&apos;&lt;/span&gt;&apos;;</div><div class="line">        &#125;</div><div class="line">        str+=&apos;&lt;/p&gt;&apos;;</div><div class="line">    &#125;</div><div class="line">    document.write(str);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<h2 id="2、选项卡实现【js】"><a href="#2、选项卡实现【js】" class="headerlink" title="2、选项卡实现【js】"></a>2、选项卡实现【js】</h2><p>在点击一个对象的时候，让所有对象的类名都清除，然后再将这个类名添加给点击的对象和点击对象对应的盒子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    var oLis=document.querySelectorAll(&apos;li&apos;),oP=document.querySelectorAll(&apos;p&apos;);</div><div class="line">    // 写一个方法</div><div class="line">    function tab(index) &#123;//index 点击对象的索引值</div><div class="line">        //1 将所有li和p标签的类名去掉</div><div class="line">        for (var i=0;i&lt;oLis.length;i++)&#123;</div><div class="line">            oLis[i].className=&apos;&apos;;</div><div class="line">            oP[i].className=&apos;&apos;;</div><div class="line">        &#125;</div><div class="line">        oLis[index].className=&apos;cur&apos;;</div><div class="line">        oP[index].className=&apos;cur&apos;;</div><div class="line">    &#125;</div><div class="line">    for (var i=0;i&lt;oLis.length;i++)&#123;</div><div class="line">        oLis[i].myIndex=i;</div><div class="line">        oLis[i].onclick=function () &#123;</div><div class="line">            tab(this.myIndex);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<h2 id="3、数组去重"><a href="#3、数组去重" class="headerlink" title="3、数组去重"></a>3、数组去重</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    var ary= [1,2,3,1,2,3];</div><div class="line">    var obj=&#123;&#125;;// 创建一个第三方盒子</div><div class="line">    for (var i=0;i&lt;ary.length;i++)&#123;//循环数组中的每一项</div><div class="line">        var cur=ary[i];</div><div class="line">        if (obj[cur]===cur)&#123;</div><div class="line">            //ary.splice(i,1);</div><div class="line">            //i--;</div><div class="line">            ary[i]=ary[ary.length-1];</div><div class="line">            ary.length--;</div><div class="line">            i--;</div><div class="line">        &#125;else &#123;</div><div class="line">            obj[cur]=cur;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    console.log(ary);</div><div class="line">    //console.dir(obj);</div><div class="line">    /*obj[ary[0]]=ary[0];  obj[1]=1</div><div class="line">    obj[ary[1]]=ary[1];  obj[&apos;a&apos;]=&apos;a&apos;</div><div class="line">    obj[ary[2]]=ary[2];  obj[3]=3</div><div class="line">    obj[ary[3]]=ary[3];  obj[&apos;a&apos;]=&apos;a&apos;  &apos;a&apos;在之前已经出现过 将这一项从ary中删除掉</div><div class="line">    ary.splice(3,1)  ary=[1,&quot;a&quot;,3,2,&quot;中&quot;,123,&apos;123&apos;]</div><div class="line"></div><div class="line">    obj[ary[3]]=ary[3];  obj[2]=2</div><div class="line">    obj[ary[4]]=ary[4];  obj[&apos;中&apos;]=&apos;中&apos;</div><div class="line">    obj[ary[5]]=ary[5];  obj[123]=123</div><div class="line">    obj[ary[6]]=ary[6];  obj[123]=&apos;123&apos;</div><div class="line">    obj=&#123;</div><div class="line">        1:1,</div><div class="line">        &apos;a&apos;:&apos;a&apos;,</div><div class="line">        3:3,</div><div class="line">        2:2,</div><div class="line">        &apos;中&apos;:&apos;中&apos;,</div><div class="line">        123:123,</div><div class="line">        &apos;123&apos;:&apos;123&apos;</div><div class="line">    &#125;*/</div><div class="line"></div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<h2 id="4、插入排序"><a href="#4、插入排序" class="headerlink" title="4、插入排序"></a>4、插入排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    var ary=[2,1,4,6,5,7,0];</div><div class="line">    var newAry=[];// 创建一个新的数组</div><div class="line">    newAry.push(ary[0]);</div><div class="line">    for (var i=1;i&lt;ary.length;i++)&#123;</div><div class="line">        for (var j=0;j&lt;newAry.length;j++)&#123;</div><div class="line">            if (ary[i]&lt;newAry[j])&#123;</div><div class="line">                newAry.splice(j,0,ary[i]);</div><div class="line">                break;</div><div class="line">            &#125;else &#123;</div><div class="line">                if (j===newAry.length-1)&#123;</div><div class="line">                    // j值和新数组在最后一项的索引值相等，</div><div class="line">                    // 说明老数组的这一项比新数组的所有项都大，</div><div class="line">                    // 直接添加到新数组末尾</div><div class="line">                    newAry.push(ary[i]);</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    console.log(newAry);</div><div class="line">    //ary[1]  newAry[?]</div><div class="line">    /*if (ary[i]&gt;newAry[j])&#123;</div><div class="line"></div><div class="line">    &#125;else &#123; &lt;=</div><div class="line"></div><div class="line">    &#125;*/</div><div class="line"></div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p><img src="/images/javascript/插入排序.png"></p>
<h2 id="5、递归"><a href="#5、递归" class="headerlink" title="5、递归"></a>5、递归</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    /*function getNum() &#123;</div><div class="line">        console.log(1);</div><div class="line">        setTimeout(getNum,1000);</div><div class="line">    &#125;</div><div class="line">    setTimeout(getNum,1000);*/</div><div class="line"></div><div class="line">    // 取 0-100的和</div><div class="line">    /*var total=null;</div><div class="line">    for (var i=0;i&lt;=100;i++)&#123;</div><div class="line">        total+=i;</div><div class="line">    &#125;</div><div class="line">    console.log(total);*/</div><div class="line"></div><div class="line">    /*function getTotal(n) &#123;</div><div class="line">        if (n===0)&#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">        return n+getTotal(n-1);</div><div class="line">    &#125;</div><div class="line">    console.log(getTotal(100));*/</div><div class="line"></div><div class="line">    // 0-100 之间既能被3整除又能被7整除的数字之和</div><div class="line"></div><div class="line">    /*function getNum(n) &#123;</div><div class="line">        if (n===0)&#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">        if (n%3===0&amp;&amp;n%7===0)&#123;</div><div class="line">            return n+getNum(n-1);</div><div class="line">        &#125;</div><div class="line">        return getNum(n-1);</div><div class="line">    &#125;</div><div class="line">    console.log(getNum(100));*/</div><div class="line"></div><div class="line"></div><div class="line">    // 任意数求和  arguments 实参集合</div><div class="line">    /*function getTotal() &#123;</div><div class="line">        //[&apos;1&apos;,&apos;3&apos;,4,5]</div><div class="line">        var total=null;</div><div class="line">        for (var i=0;i&lt;arguments.length;i++)&#123;</div><div class="line">            var cur=Number(arguments[i]);</div><div class="line">            if (!isNaN(cur)&amp;&amp;cur%3===0)&#123;</div><div class="line">                total+=cur;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return total;</div><div class="line">    &#125;</div><div class="line">    console.log(getTotal(&apos;1&apos;,&apos;3&apos;,4,5));*/</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<h2 id="6、十秒后出现的4位随机数"><a href="#6、十秒后出现的4位随机数" class="headerlink" title="6、十秒后出现的4位随机数"></a>6、十秒后出现的4位随机数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">&lt;style&gt;</div><div class="line"> div&#123;border: 2px solid #ff6700;width: 200px;height: 100px;font-size: 30px;line-height: 100px;text-align: center&#125;</div><div class="line"> &lt;/style&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;button&gt;点击开始&lt;/button&gt;</div><div class="line">&lt;div&gt;0322&lt;/div&gt;</div><div class="line">&lt;script&gt;</div><div class="line">    var oBtn=document.querySelector(&apos;button&apos;);</div><div class="line">    var oDiv=document.querySelector(&apos;div&apos;);</div><div class="line">    var temp=null;// 接收定时器的返回值</div><div class="line">    var cont=0;</div><div class="line">    function getNum() &#123;</div><div class="line">        clearTimeout(temp);</div><div class="line">        var str=&apos;&apos;;</div><div class="line">        for (var i=0;i&lt;4;i++)&#123;</div><div class="line">            str+=Math.round(Math.random()*9);</div><div class="line">        &#125;</div><div class="line">        oDiv.innerText=str;</div><div class="line">        temp=window.setTimeout(getNum,1000);</div><div class="line">        cont++;</div><div class="line">        if (cont===3)&#123;</div><div class="line">            clearTimeout(temp);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    var flag=false;</div><div class="line">    oBtn.onclick=function () &#123;</div><div class="line">        if (!flag)&#123;</div><div class="line">            getNum();</div><div class="line">            flag=true</div><div class="line">        &#125;</div><div class="line">        // temp=window.setTimeout(getNum,1000);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&lt;/script&gt;</div><div class="line">&lt;!--&lt;script&gt;</div><div class="line">    var oBtn=document.querySelector(&apos;button&apos;);</div><div class="line">    var oDiv=document.querySelector(&apos;div&apos;);</div><div class="line">    var temp=null;// 接收定时器的返回值</div><div class="line">    var con=0;</div><div class="line">    // 写一个方法 取随机整数</div><div class="line">    function getName() &#123;</div><div class="line">        var str=&apos;&apos;;// 取到的随机数都放在这个字符串中</div><div class="line">        for (var i=0;i&lt;4;i++)&#123;</div><div class="line">            str+=Math.round(Math.random()*9);</div><div class="line">        &#125;</div><div class="line">        oDiv.innerText=str;</div><div class="line">        con++;//每一次 getName执行的时候 con都会在之前的值上累加1 当con=3的时候 将定时器清除掉</div><div class="line">        if (con===3)&#123;</div><div class="line">            clearTimeout(temp);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    oBtn.onclick=function () &#123;</div><div class="line">        temp=window.setInterval(getName,1000);</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;--&gt;</div><div class="line"></div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure>
<h2 id="7、冒泡排序"><a href="#7、冒泡排序" class="headerlink" title="7、冒泡排序"></a>7、冒泡排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    //冒泡排序思想:相邻两个数进行比较</div><div class="line">    //  如果当前项比后一项大就交换位置</div><div class="line">    // 否则不交换 从小到大</div><div class="line">    var arr=[12,10,22,11,8,9,2];</div><div class="line">    //7个arr.length个 比较arr.length-1轮</div><div class="line">    //每一轮比较次数 arr.length-1-上一轮次</div><div class="line">    function popSort(arry) &#123;</div><div class="line">        for (var i=0;i&lt; arry.length-1;i++)&#123;</div><div class="line">            //控制轮数</div><div class="line">            for(var j=0;j&lt;arry.length-1-i;j++)&#123;</div><div class="line">                if(arry[j]&gt;arry[j+1])&#123;</div><div class="line">                    //如果当前项后一项大</div><div class="line">                    // (从大到小)if(arry[j]&gt;arry[i+1])</div><div class="line">                    var temp =arry[j] ;</div><div class="line">                    //先找个 空杯子 把 其中一个倒进去 再交换</div><div class="line">                    arry[j]=arry[j+1];</div><div class="line">                    arry[j+1]=temp</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        temp=null;</div><div class="line">        return arry;</div><div class="line">    &#125;</div><div class="line">    console.log(popSort(arr));</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    //    第一轮 [12, 10, 22, 11, 8, 9, 2]  第一大 （老大）22  arr.length - 1 - 0 次 6</div><div class="line">    //    12 &gt; 10  [10, 12, 22, 11, 8, 9, 2]</div><div class="line">    //    12 &lt; 22  [10, 12, 22, 11, 8, 9, 2]</div><div class="line">    //    22 &gt; 11  [10, 12, 11, 22, 8, 9, 2]</div><div class="line">    //    22 &gt; 8   [10, 12, 11, 8, 22, 9, 2]</div><div class="line">    //    22 &gt; 9   [10, 12, 11, 8, 9, 22, 2]</div><div class="line">    //    22 &gt; 2  [10, 12, 11, 8, 9, 2, 22]</div><div class="line"></div><div class="line">    // 第二轮 [10,12,11,8,9,2,22]   第二大 （老二）12   arr.length - 1 - 1次 5</div><div class="line">    //    10 &lt; 12  [10,12,11,8,9,2,22]</div><div class="line">    //    12 &gt; 11 [10,11,12,8,9,2,22]</div><div class="line">    //    12 &gt; 8  [10,11,8,12,9,2,22]</div><div class="line">    //    12 &gt; 9  [10,11,8,9,12,2,22]</div><div class="line">    //    12 &gt; 2 [10,11,8,9,2,12,22]</div><div class="line"></div><div class="line">    //    12 &gt; 22 [10,11,8,9,2,12,22] =&gt; 没必要</div><div class="line"></div><div class="line">    //    第三轮 [10,11,8,9,2,12,22]  第三大 老三 11     arr.length - 1 - 2 次 4</div><div class="line">    //    10 &lt; 11 [10,11,8,9,2,12,22]</div><div class="line">    //    11 &gt; 8  [10,8,11,9,2,12,22]</div><div class="line">    //    11 &gt; 9  [10,8,9,11,2,12,22]</div><div class="line">    //    11 &gt; 2  [10,8,9,2,11,12,22]</div><div class="line"></div><div class="line">    // 没必要</div><div class="line">    //    11 &gt; 12 [10,8,9,2,11,12,22]</div><div class="line">    //    12 &gt; 22 [10,8,9,2,11,12,22]</div><div class="line"></div><div class="line">    //    第四轮 [10,8,9,2,11,12,22] 第四大 老四 10   arr.length - 1 - 3 次 3</div><div class="line">    //    10 &gt; 8 [8,10,9,2,11,12,22]</div><div class="line">    //    10 &gt; 9 [8,9,10,2,11,12,22]</div><div class="line">    //    10 &gt; 2  [8,9,2,10,11,12,22]</div><div class="line"></div><div class="line">    // 没必要</div><div class="line">    //    10 &gt; 11  [8,9,2,10,11,12,22]</div><div class="line">    //    11 &gt; 12 [10,8,9,2,11,12,22]</div><div class="line">    //    12 &gt; 22 [10,8,9,2,11,12,22]</div><div class="line"></div><div class="line">    //    第五轮 [8,9,2,10,11,12,22] 第五大 老五 9   arr.length - 1 - 4次 2</div><div class="line">    //    8 &lt; 9 [8,9,2,10,11,12,22]</div><div class="line">    //    9 &gt; 2 [8,2,9,10,11,12,22]</div><div class="line"></div><div class="line">    // 没必要</div><div class="line">    //    9 &lt; 10 [8,2,9,10,11,12,22]</div><div class="line">    //    10 &gt; 11  [8,9,2,10,11,12,22]</div><div class="line">    //    11 &gt; 12 [10,8,9,2,11,12,22]</div><div class="line">    //    12 &gt; 22 [10,8,9,2,11,12,22]</div><div class="line"></div><div class="line">    //    第六轮 [8,2,9,10,11,12,22] 第六大 老六 8   arr.length - 1 - 5次 1</div><div class="line">    //    8 &gt; 2 [2,8,9,10,11,12,22]</div><div class="line"></div><div class="line">    //    没必要</div><div class="line">    //    8 &lt; 9 [2,8,9,10,11,12,22]</div><div class="line">    //    9 &lt; 10 [8,2,9,10,11,12,22]</div><div class="line">    //    10 &gt; 11  [8,9,2,10,11,12,22]</div><div class="line">    //    11 &gt; 12 [10,8,9,2,11,12,22]</div><div class="line">    //    12 &gt; 22 [10,8,9,2,11,12,22]</div><div class="line"></div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<h2 id="8、快速排序"><a href="#8、快速排序" class="headerlink" title="8、快速排序"></a>8、快速排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    // 快速排序 冒泡排序 数组去重</div><div class="line">    //快速排序思想：在数组中 取出中间位置的那个数 作为基准点,然后把数组中剩下的依次和这个基准点进行比较，</div><div class="line">    // 比基准点小的放在 左边数组集合 比基准点大的放在右边的数组集合，</div><div class="line">    // 左右两边集合 按照以上排序思想进行排序</div><div class="line">    // 直到数组集合中只剩下一个或空 代表排序结束</div><div class="line">    // 然后最终拼接在一起</div><div class="line">    var arr = [12, 10, 22, 11, 8, 9, 2];</div><div class="line">//    arr.sort(function (a, b) &#123;</div><div class="line">//          return a - b;</div><div class="line">//    &#125;)</div><div class="line">//     1. 取出数组中中间位置那个数 ： leng/2 =&gt; 7/2 =&gt; Math.floor(length/2) =&gt; 3 arr[3] =&gt; arr.splice(3,1) =&gt; [11] =&gt; [11][0] =&gt;11</div><div class="line">//    2.for 依次拿出 和基准点进行比较 left []  right[]</div><div class="line"></div><div class="line">    function quickSort(arry) &#123;</div><div class="line">         if(arry.length &lt;= 1)&#123;</div><div class="line">             return arry;</div><div class="line">         &#125;</div><div class="line">         var midInd = Math.floor(arry.length/2);</div><div class="line">        // 得到中间位置的索引</div><div class="line">         var midNum = arry.splice(midInd,1)[0];</div><div class="line">        // 把中间这个数在数组中取出来 作为基准点</div><div class="line">         var left = [];  // 用来存放比基准点小的</div><div class="line">         var right = []; // 用来存放比基准点大的</div><div class="line">         for(var i = 0; i &lt; arry.length; i++)&#123;</div><div class="line">             // 把数组中里每一项依次拿出 和基准点 进行比较</div><div class="line">             var cur = arry[i];</div><div class="line">                 if(cur &lt; midNum)&#123; // 比基准点小的 放到 left集合</div><div class="line">                     left.push(cur);</div><div class="line">                 &#125; else &#123;  // 比基准点大的 放到 right 集合</div><div class="line">                     right.push(cur);</div><div class="line">                 &#125;</div><div class="line">         &#125;</div><div class="line">//                [8]left最终返回值.concat(midNum, right最终返回值)</div><div class="line">         return quickSort(left).concat(midNum,quickSort(right));</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    console.log(quickSort(arr));</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<h2 id="9、in"><a href="#9、in" class="headerlink" title="9、in"></a>9、in</h2><p>in:验证某一个属性是否属于这个对象（不管是私有的属性还是公有的属性，只要有返回结果就是true）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">    name:&apos;陈卉&apos;,</div><div class="line">    age:81</div><div class="line">&#125;;</div><div class="line">console.log(&apos;name&apos;in obj);//-&gt;true</div><div class="line">console.log(&apos;sex&apos;in obj);//-&gt;true</div><div class="line">console.log(name in obj);//-&gt;window.name in obj -&gt;&apos;&apos; in obj -&gt;flase 如果name不加引号它的意思是把name这个变量存储值作为检测的依据，来检测存储的这个值是否为obj的一个属性，加引号&apos;name&apos;就是属性名，验证obj中是否有name这个属性</div><div class="line">console.log(age in obj);//-&gt;Uncaught ReferenceError:age is not defined</div></pre></td></tr></table></figure></p>
<h2 id="10、严格模式与非严格模式"><a href="#10、严格模式与非严格模式" class="headerlink" title="10、严格模式与非严格模式"></a>10、严格模式与非严格模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">//预解释、变量提升</div><div class="line"></div><div class="line">//预解释：var num; (undefined-&gt;全局下有一个叫做num的变量了，在全局下声明相当于给window增加了一个属性名-&gt;window.num = undefined)</div><div class="line">console.log(num);//-&gt;undefined</div><div class="line">if(!(&apos;num&apos; in window))&#123;//-&gt;&apos;num&apos; in window=&gt;TRUE</div><div class="line">   var num = 100;</div><div class="line">&#125;</div><div class="line">console.log(num);//-&gt;undefined</div><div class="line"></div><div class="line">//</div><div class="line">var name =&apos;中国&apos;;</div><div class="line">var age = 5000;</div><div class="line">age = (function(name,age)&#123;//-&gt;形参：变量</div><div class="line">    name =&apos;hui&apos;;</div><div class="line">    age = age||this.age;</div><div class="line">    this.name = arguments[0];</div><div class="line">    console.log(name,age);</div><div class="line">&#125;)(name,age);//实参：具体值 把全局下变量的值当做实参传递给私有作用域的形参=&gt;(&apos;中国&apos;,5000)</div><div class="line">console.log(name,age)</div><div class="line"></div><div class="line"></div><div class="line">//&quot;use strict&quot;;//-&gt;使用JS中的严格模式</div><div class="line">function fn(a,b,c)&#123;</div><div class="line">    //非严格模式下</div><div class="line">    //1)arguments 和 形参存在映射的关系：一个该另外一个也跟着改</div><div class="line"></div><div class="line">    //严格模式下</div><div class="line">    //arguements 和 形参之间没有映射关系</div><div class="line"></div><div class="line">    //-&gt;arguments.callee:指向的是当前函数本身，这里代表的就是当前的函数fn</div><div class="line">    //-&gt;arguments.callee.caller:当前函数是在哪个函数中执行的，那么caller就指向这个函数，如果是在window下执行的，caller值是null</div><div class="line">    //-&gt;严格模式下会报错：Uncaught TypeError:&apos;caller&apos;,&apos;callee&apos;,and&apos;arguments&apos;properties may not be accessed on strict mode function or the arguments objects for calls to them 严格模式下不允许我们使用call或者caller属性</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="11、研究数组"><a href="#11、研究数组" class="headerlink" title="11、研究数组"></a>11、研究数组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//研究数组：创建数组类Array的一个实例（创建数组）</div><div class="line">var ary = [12,23];//-&gt;字面量创建方式</div><div class="line">var ary2 = new Array(&apos;12&apos;);//-&gt;实例创建方式（面向对象创建）</div><div class="line">//new Array(12)括号中的数字是设定数组的长度，而不是给增加值</div><div class="line">//new Array(&apos;12&apos;)这样才是给数组第一项设定为12，数组有一项</div><div class="line">//new Array(12,23)这样有两项，分别是12和23</div><div class="line">console.log(ary);</div><div class="line">console.log(ary2);</div></pre></td></tr></table></figure>
<h2 id="12、创建类"><a href="#12、创建类" class="headerlink" title="12、创建类"></a>12、创建类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//-&gt;创建的类第一个字母最好大写</div><div class="line">function Person()&#123;</div><div class="line">   //-&gt;看不见：var obj=&#123;&#125; THIS-&gt;obj</div><div class="line">   //-&gt;看不见：return obj ;/ return this;</div><div class="line">&#125;</div><div class="line">//  var a=Person();//-&gt;此时的Person仅仅是一个普通的函数，走的是函数那一套流程：创建私有的作用域-&gt;赋/预-&gt;依次执行代码（私有变量还是全局变量=&gt;作用域链）-&gt;作用域是否销毁“生命周期”</div><div class="line">//console.log(a);//-&gt;undefined 因为函数执行的时候没有返回值</div><div class="line"></div><div class="line">var p = new Person();//-&gt;这样执行Person就是一个类了，它的执行步骤：</div><div class="line">// 1）也和普通函数执行一样，创建一个私有的作用域，进行形参赋值和预解释</div><div class="line">//2）new 这样执行，在预解释完成后，浏览器会默认的在私有作用域创建一个对象，而且函数中的this就指向这个对象</div><div class="line">//3）然后在和普通函数一样，代码从上到下执行（作用域链）</div><div class="line">//4）new 这样执行，在代码执行完成后，会默认的把第二步中我们创建的这个对象返回</div><div class="line"></div><div class="line">//-&gt;这种执行方式叫做构造函数模式，new Person() Person就是一个类（自定义类），而返回的结果p就是一个实例</div><div class="line">console.log(p);</div><div class="line"></div><div class="line"></div><div class="line">//this问题 普通函数执行，方法中的this取决于函数执行的时候前面是否有“.”，有的话点前面是谁this就指向谁，没有的话this执行window； 构造函数模式下，方法中的this指向的是当前类的实例</div></pre></td></tr></table></figure>
<h2 id="13、构造函数"><a href="#13、构造函数" class="headerlink" title="13、构造函数"></a>13、构造函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function Student(name,age)&#123;</div><div class="line">    this.name = name;</div><div class="line">    this.age = age;</div><div class="line">&#125;</div><div class="line">//Student(); //-&gt;普通函数执行   Studenthoumi；//函数的一个定义体（函数本身）</div><div class="line"></div><div class="line">var st1 = new Student(&apos;陈&apos;,22);//-&gt;在构造函数模式执行的时候，如果不需要传递参数，后面的小括号可不加，没什么区别</div><div class="line">var st2 = new Student(&apos;卉&apos;,21);</div><div class="line"></div><div class="line">///-&gt;通过构造函数创建出来的实例都是相互独立的个体，互相不影响，而在构造函数体中写的this.xxx =xxx都相当于给当前的实例增加属于自己的私有属性</div><div class="line">// -&gt; 类的数据类型：函数数据类型 typeof Student =&gt;&apos;function&apos;</div><div class="line">// -&gt;实例数据类型：对象数据类型  typeof str1 =&gt;&apos;object&apos;</div></pre></td></tr></table></figure>
<h2 id="14、检测"><a href="#14、检测" class="headerlink" title="14、检测"></a>14、检测</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function Fn(name)&#123;</div><div class="line">    var school = &apos;秋月&apos;;</div><div class="line">    this.name = name;</div><div class="line">    this.say = function()&#123;</div><div class="line">        console.log(&apos;my name is&apos; + this.name +&apos;,i study in the&apos; + school);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line">var f1 = new Fn(&apos;陈卉&apos;);</div><div class="line">// console.log(f1);//-&gt;实例：如果我们手动返回的结果是一个基本数据类型值，对最后的实例没有任何的影响</div><div class="line">// console.log(f1);//-&gt;新的对象：如果我们手动返回的结果是一个引用数据类型的值，会把默认返回的实例覆盖掉，此时的f1就不是类的实例了</div><div class="line"></div><div class="line">console.log(&apos;say&apos; in f1);//-&gt;TRUE 检测say是否为f1的一个属性</div><div class="line">console.log(f1.hasOwnProperty(&apos;say&apos;));//-&gt;hasOwnProperty:检测属性是否为对象（实例）的私有属性-&gt;true</div><div class="line">                                      //-&gt;in:不管当前的属性是私有的还是公有的，只要有返回的结果就是true</div><div class="line">//-&gt;hasOwnProperty：只有是私有的属性才会返回true，即使你公有里面有这个属性，但是如果私有中没有，返回结果也是false</div><div class="line"></div><div class="line">//-&gt;检测某一个对象是否拥有某一个公有的属性：检测attr是否为obj的公有属性</div><div class="line">function hasPublicProperty(obj,attr)&#123;</div><div class="line">    return (attr in obj)&amp;&amp;!obj.hasOwnProperty(attr);</div><div class="line">&#125;</div><div class="line">hasPublicProperty(f1,&apos;say&apos;);//-&gt;false</div></pre></td></tr></table></figure>
<h2 id="15、单例误区"><a href="#15、单例误区" class="headerlink" title="15、单例误区"></a>15、单例误区</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">//-&gt;单例模式</div><div class="line">    var personRender = &#123;&#125;;</div><div class="line">    var studentRender = (function () &#123;</div><div class="line">        return &#123;</div><div class="line"></div><div class="line">       &#125;</div><div class="line">    &#125;)();</div><div class="line"></div><div class="line">//-&gt;构造函数模式（有一些 人 认为这个才是单例模式）</div><div class="line">   function Person() &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    var p = new Person();</div><div class="line"></div><div class="line"></div><div class="line">//-&gt;什么叫做闭包?</div><div class="line">//函数执行形成一个私有的作用域=&gt;闭包</div><div class="line">    function fn() &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    fn();</div><div class="line"></div><div class="line">//-&gt;外界 很多都认为只有形成一个不销毁的私有作用域才叫做闭包</div><div class="line">    (function () &#123;</div><div class="line"></div><div class="line">    &#125;)();</div><div class="line">    function fn() &#123;</div><div class="line">        return function () &#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    var f = fn();</div></pre></td></tr></table></figure>
<h2 id="16、原型批量设置"><a href="#16、原型批量设置" class="headerlink" title="16、原型批量设置"></a>16、原型批量设置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">function Fn()&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">Fn.prototype.x = 10;</div><div class="line">Fn.prototype.y = 10;</div><div class="line">Fn.prototype.xx = 10;</div><div class="line">//批量添加公有属性</div><div class="line">Fn.protype = &#123;</div><div class="line">  constructor:Fn,</div><div class="line">  x: 10,</div><div class="line">  y: 10,</div><div class="line">  xx: 10</div><div class="line">&#125;;</div><div class="line">//需要我们自己手动添加constructor 指向</div><div class="line"></div><div class="line">//内置类添加公有属性</div><div class="line">Array.prototype.mySlice = function ()&#123;</div><div class="line">   console.log(&apos;mySlice&apos;);</div><div class="line">&#125;;</div><div class="line">[].mySlice();</div><div class="line">   console.log([1,2,4].slice())</div><div class="line"></div><div class="line"></div><div class="line">//重构内置类原型对象的时候 被浏览器屏蔽掉了</div><div class="line">//如果 我们自己动手为内置类原型开辟一个堆内存 就会将 内置类修改 将浏览器天生给开辟的原型对象 替换掉，导致 在内置类原有 属性和方法 都是被替换掉了</div><div class="line">Array.prototype = &#123;</div><div class="line">   mySlice: function ()&#123;</div><div class="line">       console.log(&apos;mySlice&apos;);</div><div class="line">   &#125;</div><div class="line">&#125;;</div><div class="line">[].mySlice();</div><div class="line">   // console.log([1,2,4].slice());</div><div class="line"></div><div class="line"></div><div class="line">//在给内置类原型上添加属性和方法的时候 需要一个一个添加</div><div class="line">// 如果内置类原型上有的属性 我们添加的和原有的名字一样 就会被我们添加后的 覆盖掉</div><div class="line">//当在内置类原型添加 属性的时候 注意 命名 可以加前缀</div><div class="line">Array.prototype.mySlice = function()&#123;</div><div class="line">   console.log(&apos;mySlice&apos;);</div><div class="line">   return 123;</div><div class="line">&#125;;</div><div class="line">Array.prototype.slice = function()&#123;</div><div class="line">   console.log(&apos;slice&apos;);</div><div class="line">   return 123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="重构对象原型"><a href="#重构对象原型" class="headerlink" title="重构对象原型"></a>重构对象原型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function Fn()&#123;</div><div class="line">&#125;</div><div class="line">//console log(Fn.prototype) 每个类天生自带的属性 浏览器为它开辟了一个堆内存 里面有一个天生自带的属性 constructor，coustructor指向当前函数（类）本身</div><div class="line">Fn.prototype = &#123;</div><div class="line">   constructor: Fn,</div><div class="line">   y: 10</div><div class="line">&#125;;</div><div class="line">var f1 = new Fn;</div><div class="line">console.log(Fn.prototype);</div><div class="line">console.Log(f1.constructor);</div><div class="line">//重构原型对象 自己开辟的堆内存 来存储公有的属性和方法 将浏览器天生为Fn.Prototype开辟的堆内存替换掉</div><div class="line">//f1.constructor 由于我们为Fn.prototype新开辟了一个堆内存，所以最终通过原型链查找 找到的是Object.prototype上constructor=&gt;Object</div><div class="line"></div><div class="line">//只有浏览器天生为Fn.prototype开辟的堆内存才有constructor这个属性 我们自己开辟的堆内存没有constructor这个属性</div><div class="line">//为了和原来 一样 就自己手动在 自己为Fn.prototype开辟的堆内存里添加constructor 指向Fn</div></pre></td></tr></table></figure>
<h2 id="封装的类库-utils-js"><a href="#封装的类库-utils-js" class="headerlink" title="封装的类库 utils.js"></a>封装的类库 utils.js</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//类数组转化为数组</div><div class="line">function listToArray(list)&#123;</div><div class="line">   console.log(list);</div><div class="line">   try&#123;</div><div class="line">       return [].slice.call(list,0);</div><div class="line">   &#125;catch(e)&#123;</div><div class="line">      var arr = [];</div><div class="line">      for(var i=0;i&lt;list.length;i++)&#123;</div><div class="line">          arr.push(list[i]);</div><div class="line">      &#125;</div><div class="line">      return arr;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2017/07/18/JavaScript /">
    <time datetime="2017-07-18T13:05:39.625Z" class="entry-date">
        2017-07-18
    </time>
</a>
    
    
    </footer>
</article>


    
<nav class="nav-single">
    <h3 class="assistive-text">文章导航</h3>
    
        <span class="nav-previous"><a href="/2017/08/06/linux/" rel="prev"><span class="meta-nav">←</span> linux常用命令</a></span>
    
    
        <span class="nav-next"><a href="/2017/07/16/html5+css3/" rel="next">HTML5+CSS3 <span class="meta-nav">→</span></a></span>
    
</nav><!-- .nav-single -->







</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value="" name="s" id="s" />
        <input type="submit" id="searchsubmit" value="搜索" />
    </div>
</form></aside>
  
    
  
    
  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/2017/09/06/echarts/">echarts</a>
          </li>
        
          <li>
            <a href="/2017/08/06/linux/">linux常用命令</a>
          </li>
        
          <li>
            <a href="/2017/07/18/JavaScript /">JavaScript</a>
          </li>
        
          <li>
            <a href="/2017/07/16/html5+css3/">HTML5+CSS3</a>
          </li>
        
          <li>
            <a href="/2017/07/06/html+css/">html+css</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  
    
  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2017 卉卉
    All rights reserved.</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</footer>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>

<script src="/js/jquery-2.0.3.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
</body>
</html>