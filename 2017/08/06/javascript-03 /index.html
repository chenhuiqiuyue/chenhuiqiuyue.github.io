<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <meta name="description" content="javascript知识1、预解释（变量提升）
浏览器加载html时候，会提供一个供js代码执行的环境 -&amp;gt; window(全局作用域)

在当前作用域中，js代码执行之前，把所有带var和带function关键字的进行声明或者定义

var和function的预解释的区别

通过var声明的" />
  

  
  
  
  
  
  
  <title>javascript-03 | 秋月</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="javascript知识1、预解释（变量提升） 浏览器加载html时候，会提供一个供js代码执行的环境 -&amp;gt; window(全局作用域)  在当前作用域中，js代码执行之前，把所有带var和带function关键字的进行声明或者定义  var和function的预解释的区别  通过var声明的时候 会给变量赋值一个默认值undefined  预解释的时候 带var只声明 不定义  带func">
<meta property="og:type" content="article">
<meta property="og:title" content="javascript-03">
<meta property="og:url" content="http://yoursite.com/2017/08/06/javascript-03 /index.html">
<meta property="og:site_name" content="秋月">
<meta property="og:description" content="javascript知识1、预解释（变量提升） 浏览器加载html时候，会提供一个供js代码执行的环境 -&amp;gt; window(全局作用域)  在当前作用域中，js代码执行之前，把所有带var和带function关键字的进行声明或者定义  var和function的预解释的区别  通过var声明的时候 会给变量赋值一个默认值undefined  预解释的时候 带var只声明 不定义  带func">
<meta property="og:image" content="http://yoursite.com/images/javascript/栈内存和堆内存.png">
<meta property="og:image" content="http://yoursite.com/images/javascript/栈内存里产生堆内存.png">
<meta property="og:image" content="http://yoursite.com/images/javascript/作用域选项卡.png">
<meta property="og:image" content="http://yoursite.com/images/javascript/原型链.png">
<meta property="og:image" content="http://yoursite.com/images/javascript/简单交互过程.png">
<meta property="og:updated_time" content="2017-09-02T09:21:54.945Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="javascript-03">
<meta name="twitter:description" content="javascript知识1、预解释（变量提升） 浏览器加载html时候，会提供一个供js代码执行的环境 -&amp;gt; window(全局作用域)  在当前作用域中，js代码执行之前，把所有带var和带function关键字的进行声明或者定义  var和function的预解释的区别  通过var声明的时候 会给变量赋值一个默认值undefined  预解释的时候 带var只声明 不定义  带func">
<meta name="twitter:image" content="http://yoursite.com/images/javascript/栈内存和堆内存.png">
  
  
    <link rel="icon" href="/css/images/me.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  

  
  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>
</head>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/" title="秋月" rel="home">秋月</a>
      </h1>
      
        <script type="text/javascript" src="http://api.hitokoto.us/rand?encode=js&charset=utf-8"></script>
        <h2 class="site-description"><script>hitokoto();</script></h2>
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/">Home</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/archives">Archives</a></li>
                
                </ul>
            </div>
    </nav>
</header>
      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main"><article id="post-javascript-03 " class="post-javascript-03  post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title article-title">
      javascript-03
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2017/08/06/javascript-03 /" data-id="cj7fxldti000gp8fxhmhhgv64" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="javascript知识"><a href="#javascript知识" class="headerlink" title="javascript知识"></a>javascript知识</h1><h2 id="1、预解释（变量提升）"><a href="#1、预解释（变量提升）" class="headerlink" title="1、预解释（变量提升）"></a>1、预解释（变量提升）</h2><blockquote>
<p>浏览器加载html时候，会提供一个供js代码执行的环境 -&gt; window(全局作用域)</p>
</blockquote>
<p>在当前作用域中，js代码执行之前，把所有带var和带function关键字的进行声明或者定义</p>
<ul>
<li><p>var和function的预解释的区别</p>
<ul>
<li><p>通过var声明的时候 会给变量赋值一个默认值undefined</p>
</li>
<li><p>预解释的时候 带var只声明 不定义</p>
</li>
<li><p>带function 预解释的时候 声明加定义 预解释完成后 代码自上而下开始执行</p>
</li>
</ul>
</li>
<li><p>全局变量和私有变量</p>
<ul>
<li><p>全局变量 就是 在全局作用域中声明的变量</p>
</li>
<li><p>私有变量 就是 在私有作用域中声明的变量（形参和预解释的声明的变量）</p>
</li>
<li><p>函数执行 将函数里的js代码加载运行 也需要一个供函数里js代码执行的环境 -&gt;私有作用域【1、给形参赋值–&gt;2、进行预解释–&gt;3、从上到下执行】</p>
</li>
</ul>
</li>
</ul>
<p>预解释是针对于当前作用域 只发生在当前作用域中 首先开始对window进行预解释 函数执行的时候会形成一个私有作用域 然后 函数执行的时候也会进行 预解释</p>
<h2 id="2、作用域链"><a href="#2、作用域链" class="headerlink" title="2、作用域链"></a>2、作用域链</h2><p>如果在私用作用域遇到一个变量，首先看是不是形参或者有没有在当前作用域预解释的时候声明过，如果没有声明过也不是形参 就会去上级作用域中查找，一直找到window为止</p>
<p>如何看上级作用域，就看 函数是在哪里定义的</p>
<h2 id="3、预解释无节操"><a href="#3、预解释无节操" class="headerlink" title="3、预解释无节操"></a>3、预解释无节操</h2><p>1、不管if条件是否成立都会进行预解释</p>
<p>2、预解释的时候不会 声明等号右边的【return 下面的代码虽然不执行，也要进行预解释；但是return 右边 不会进行预解释 因为把它当做一个值返回出去】</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>1、闭包：当一个方法在运行的时候，就会形成一个私有作用域，在这个作用域里，里面定义的变量不会受到上级作用域或其他作用域的影响，不会和全局或其它作用域里的变量有冲突。这个由方法运行而产生的私有作用作用域，就叫闭包。【闭包为函数运行机制】</p>
<p>2、闭包其实就是函数在运行的时候产生的那个私有作用域。【为了让变量更安全，让一个环境中的变量与其它环境中的变量隔离开不产生冲突】</p>
<p>3、例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">var name = &apos;chenhui&apos;;</div><div class="line">var age = &apos;twenty-two&apos;;</div><div class="line">//定义一个匿名函数再让这个匿名函数运行，并给匿名函数传递参数</div><div class="line">(function (chinaName, chinaAge) &#123;//这里是给匿名方法定义的形式参数</div><div class="line">    var name = &apos;陈卉&apos;;</div><div class="line">    var age = 22;</div><div class="line">    console.log(chinaName + &apos;有&apos; + chinaAge + &apos;岁。&apos; + name + &apos;有&apos; + age + &apos;岁。&apos;);//chenhui有twenty-two岁。陈卉有22岁。</div><div class="line">&#125;)(name, age);//这里是给匿名方法传的函数</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p>在这个例子里，定义了两个全局变量name和age，下面的匿名函数里也定义了变量name和age，但这两组相同的变量互不影响，匿名方法的变量属于自己的私用有的作用域，这个运行的匿名方法就形成闭包。如果这个匿名方法想用到全局变量name和age，也可以通过传参数的方式传给这个匿名函数。有名函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function fn(chinaName, chinaAge) &#123;//给刚才的匿名函数一个是有名函数而已</div><div class="line">    var name = &apos;陈卉&apos;;</div><div class="line">    var age = 22;</div><div class="line">    console.log(chinaName + &apos;有&apos; + chinaAge + &apos;岁。&apos; + name + &apos;有&apos; + age + &apos;岁。&apos;);。</div><div class="line">&#125;</div><div class="line">fn(name, age);//让函数执行  chenhui有twenty-two岁。陈卉有22岁</div></pre></td></tr></table></figure></p>
<p>让这个匿名函数访问到全局变量name和age还有一种方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(function (chinaName, chinaAge) &#123;</div><div class="line">    var name = &apos;陈卉&apos;;</div><div class="line">    var age = 22;</div><div class="line">    console.log(window.name + &apos;有&apos; + window.age + &apos;岁。&apos; + name + &apos;有&apos; + age + &apos;岁。&apos;);//chenhui有twenty-two岁。陈卉有22岁。</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>定义在闭包里的变量和函数在全局下不能使用的，如何让定义在闭包里的函数能在闭包外面使用，方法是把它赋值给一个全局变量，如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(function (chinaName, chinaAge) &#123;</div><div class="line">    var name = &apos;陈卉&apos;;</div><div class="line">    var age = 22;</div><div class="line">    function change()&#123;//这个函数是私有，外部不能访问，这就形成了一个闭包方法</div><div class="line">     console.log(window.name + &apos;有&apos; + window.age + &apos;岁。&apos; + name + &apos;有&apos; + age + &apos;岁。&apos;);</div><div class="line">    &#125;</div><div class="line">    window.chenhuiqiuyue=change;</div><div class="line">&#125;)();</div><div class="line">    chenhuiqiuyue();//运行这个方法  chenhui有twenty-two岁。陈卉有22岁。</div></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="重复声明"><a href="#重复声明" class="headerlink" title="重复声明"></a>重复声明</h2><p>预解释 带var不重复声明 带function 不重复声明 但重复定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function fn = log(2) = log(12) = log(13)(var fn 不重复声明) = log(123)</div><div class="line">console.log(fn);//输出函数本身 function fn()&#123;console.log(123)&#125;</div><div class="line">fn();//123</div><div class="line">function fn() &#123;console.log(2)&#125;</div><div class="line">fn(); //123</div><div class="line">function fn() &#123;console.log(12)&#125;</div><div class="line">fn();//123</div><div class="line">function fn() &#123;console.log(13)&#125;</div><div class="line">var fn = 666; //fn = 123</div><div class="line">function fn () &#123; console.log(123)&#125;</div><div class="line">console.log(fn) ;//666</div><div class="line">fn();// 666() 报错 fn is not a function</div></pre></td></tr></table></figure></p>
<p>计算例1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function fn2(num)&#123;</div><div class="line">   num  = 123; //num = 20 修改为 num = 123;</div><div class="line">   var num = 100; //num = 100;</div><div class="line">   return function () &#123;</div><div class="line">      console.log(num);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">var f2 = f2(20);</div><div class="line">f2();//100;</div></pre></td></tr></table></figure></p>
<p>计算例2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">console.log(fn2);</div><div class="line">function fn2()&#123;  //A</div><div class="line">    console.log(2222);</div><div class="line">&#125;</div><div class="line">fn2();</div><div class="line">function fn2()&#123; //B B把A覆盖掉</div><div class="line">    console.log(6666);</div><div class="line">&#125;</div><div class="line">fn2();</div><div class="line">console.log(ni); //undefined</div><div class="line">var ni = 123;</div><div class="line">console.log(ni);// 123</div><div class="line">var ni = 666;</div><div class="line">console.log(ni);//666</div></pre></td></tr></table></figure></p>
<h2 id="堆内存和栈内存"><a href="#堆内存和栈内存" class="headerlink" title="堆内存和栈内存"></a>堆内存和栈内存</h2><p>1、推内存  用来存储引用数据类型的值</p>
<p>2、栈内存 供js代码执行的环境</p>
<p><img src="/images/javascript/栈内存和堆内存.png"></p>
<p>3、堆内存释放</p>
<ul>
<li>浏览器默认机制 每间隔一段时间 会把那些 没有被占用的 内存回收释放</li>
</ul>
<p>4、栈内存销毁与不销毁<br>window（栈内存）关闭浏览器的时候会销毁<br>一般情况下函数形成私有作用域（栈内存）执行完里面代码 就会立即销毁</p>
<p>5、模拟简单投票 利用全局不销毁的情况 来实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">&lt;p&gt;</div><div class="line">   &quot;点赞&quot;</div><div class="line">   &lt;span id=&quot; totals&quot;&gt;0&lt;/span&gt;</div><div class="line">&lt;/p&gt;</div><div class="line">&lt;button&gt;点赞&lt;button&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">   var btn = document.getElementByTagName(&apos;button&apos;)[0];</div><div class="line">   var totals = document.getElementById(&apos;totals&apos;);</div><div class="line">   //利用全局作用域不销毁的情况 来保存我们每一次修改count的值</div><div class="line">   var count = 0;</div><div class="line">   btn.onclick = function()&#123;</div><div class="line">       count++;</div><div class="line">       totals.innerHTML = count;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   //自己创建一个不销毁的作用域 来保存每一次修改后count的值</div><div class="line">   ~(function()&#123;</div><div class="line">        var count = 0;</div><div class="line">        function f()&#123;</div><div class="line">            count++;</div><div class="line">            totals.innerHTML = count;</div><div class="line">        &#125;</div><div class="line">        btn.onclick = f;</div><div class="line">   &#125;)()</div><div class="line"></div><div class="line">   //btn主动去里面占用 自执行函数里 定义的 function</div><div class="line">   ~(function()&#123;</div><div class="line">         var count = 0;</div><div class="line">         btn.onclick = function ()&#123;</div><div class="line">             count++;</div><div class="line">             totals.innerHTML = count;</div><div class="line">         &#125;;</div><div class="line">   &#125;)()</div><div class="line"></div><div class="line">   //btn在外面等着 自执行函数 主动将在它里面定义的function 让拜托你接收</div><div class="line">   btn.onclick = (function()&#123;</div><div class="line">       var count = 0;</div><div class="line">       return function()&#123;</div><div class="line">         console.log(count);</div><div class="line">         count++;</div><div class="line">         totals.innerHTML = count;</div><div class="line">       &#125;</div><div class="line">   &#125;)();</div><div class="line">   console.log(btn.onclick);</div><div class="line"></div><div class="line">   // 内容自身加一</div><div class="line">   btn.onclick = function()&#123;</div><div class="line">        totals.innerHTML = ++totals.innerHTML;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   //利用自定义属性</div><div class="line">   btn.count = 0;</div><div class="line">   btn.onclick = function()&#123;</div><div class="line">       totals.innerHTML = ++this.count;</div><div class="line">   &#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure></p>
<p><img src="/images/javascript/栈内存里产生堆内存.png"></p>
<p>7、利用作用作用域不销毁完成选项卡<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div></pre></td><td class="code"><pre><div class="line">&lt;style&gt;</div><div class="line">      *&#123;</div><div class="line">         margin: 0;</div><div class="line">         padding: 0;</div><div class="line">      &#125;</div><div class="line">      a&#123;</div><div class="line">         text-decoration: none;</div><div class="line">      &#125;</div><div class="line">      ul&#123;</div><div class="line">         list-style: none;</div><div class="line">         width:302px;</div><div class="line">      &#125;</div><div class="line">      body&#123;</div><div class="line">          font: 12px/1.5 &quot;Microsoft Himalaya&quot;;</div><div class="line">          background: #59afe4;</div><div class="line">      &#125;</div><div class="line">      .box&#123;</div><div class="line">           margin: 30px auto;</div><div class="line">           width: 300px;</div><div class="line">           boder: 1px solid #222；</div><div class="line">           boder-radius: 3px;</div><div class="line">           background: #fff;</div><div class="line">           overflow: hidden;</div><div class="line">      &#125;</div><div class="line">      .clearfix:after&#123;</div><div class="line">          display: block;</div><div class="line">          content: &quot;&quot;;</div><div class="line">          clear: both;</div><div class="line">      &#125;</div><div class="line">      ul li&#123;</div><div class="line">           float: left;</div><div class="line">           boder-bottom: 1px solid #222;</div><div class="line">           width: 74px;</div><div class="line">           height: 41px;</div><div class="line">           line-height: 41px;</div><div class="line">           text-align: center;</div><div class="line">           cursor: pointer;</div><div class="line">      &#125;</div><div class="line">      ul li.cur &#123;</div><div class="line">           margin-left: -1px;</div><div class="line">           padding-right: 3px;</div><div class="line">           border-bottom-color: #fff;</div><div class="line">           border-left: 1px solid #222;</div><div class="line">           border-right: 1px solid #222;</div><div class="line">           width: 150px;</div><div class="line">      &#125;</div><div class="line">      p&#123;</div><div class="line">          display: none;</div><div class="line">          text-align: center;</div><div class="line">          line-height: 50px;</div><div class="line">      &#125;</div><div class="line">      p.cur&#123;</div><div class="line">           display: block;</div><div class="line">      &#125;</div><div class="line">      ul li a&#123;</div><div class="line">           color: orangered;</div><div class="line">           font-size: 10px;</div><div class="line">      &#125;</div><div class="line">      ul li a:hover&#123;</div><div class="line">            text-decoration: underline;</div><div class="line">      &#125;</div><div class="line">      ul li span&#123;</div><div class="line">          color: orangered;</div><div class="line">          display: none;</div><div class="line">      &#125;</div><div class="line">      ul li.cur span&#123;</div><div class="line">         discplay: inline-block;</div><div class="line">      &#125;</div><div class="line">&lt;/style&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;div class= &quot;box&quot;&gt;</div><div class="line">  &lt;ul class=&quot;clearfix&quot;&gt;</div><div class="line">     &lt;li&gt;</div><div class="line">       我的电影</div><div class="line">       &lt;span&gt;</div><div class="line">           /</div><div class="line">          &lt;a href=&quot;#&quot;&gt;更多&lt;/a&gt;</div><div class="line">       &lt;/span&gt;</div><div class="line">     &lt;/li&gt;</div><div class="line">     &lt;li class=&quot;cur&quot;&gt;</div><div class="line">       我的音乐</div><div class="line">       &lt;span&gt;</div><div class="line">           /</div><div class="line">          &lt;a href=&quot;#&quot;&gt;更多&lt;/a&gt;</div><div class="line">       &lt;/span&gt;</div><div class="line">     &lt;/li&gt;</div><div class="line">     &lt;li&gt;</div><div class="line">       我的电视剧</div><div class="line">       &lt;span&gt;</div><div class="line">          /</div><div class="line">          &lt;a href=&quot;#&quot;&gt;更多&lt;/a&gt;</div><div class="line">       &lt;/span&gt;</div><div class="line">     &lt;/li&gt;</div><div class="line">  &lt;/ul&gt;</div><div class="line">  &lt;p&gt;速度与激情&lt;/p&gt;</div><div class="line">  &lt;p class=&quot;cur&quot;&gt;女人花&lt;/p&gt;</div><div class="line">  &lt;p&gt;欢乐颂&lt;/p&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;script&gt;</div><div class="line">var oLis = document.querySelectorAll(&apos;li&apos;),oPs = document.querySelectorAll(&apos;p&apos;);</div><div class="line"></div><div class="line">// 作用域方式一 利用不销毁作用域（弊端会形成多个不销毁作用域）</div><div class="line">   for(var i=0;i&lt;oLis.length;i++)&#123;</div><div class="line">       oLis[i].onclik = (function(n)&#123; //让li在外面接收 每一次自执行函数里返回的内部函数 导致当前自执行函数 形成的作用域 不能销毁</div><div class="line">       return function()&#123;</div><div class="line">          console.log(n);</div><div class="line">            for(var j = 0;j&lt;oLis.length;j++)&#123;</div><div class="line">               oLis[j].className = oPs[j].className =&apos;&apos;;</div><div class="line">            &#125;</div><div class="line">            this.className = oPs[n].className = &apos;cur&apos;;</div><div class="line">       &#125;</div><div class="line">       &#125;)(i);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   //作用域方式二 利用不销毁作用域 （弊端会形成多个不销毁作用域）</div><div class="line">   for (var i=0; i&lt;oLis.length;i++)&#123; //每一轮都会形成一个不销毁的作用域</div><div class="line">        (function(n)&#123;</div><div class="line">            oLis[n].onclick = function()&#123; //我们主动跑到里面来占用 在这里面定义的function 并把for循环的每一轮的值 传递进来 赋给每一个不销毁的作用域里的形参n来保存当前这一轮i的值</div><div class="line">               console.log(n);</div><div class="line">               for(var j=0;j&lt;oLis.length;j++)&#123;</div><div class="line">                   oLis[j].className =oPs[j].className =&apos;&apos;;</div><div class="line">               &#125;</div><div class="line">               this.className = oPs[n].className = &apos;cur&apos;;</div><div class="line">            &#125;</div><div class="line">        &#125;)(i);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   //自定义属性（推荐）</div><div class="line">   for(var i=0;i&lt;oLis.length;i++)&#123;</div><div class="line">       oLis[i].joo = i;</div><div class="line">       oLis[i].onclick = function()&#123;</div><div class="line">            for(var j=0;j&lt;oList.length;j++)&#123;</div><div class="line">                oLis[j].className=&apos;&apos;;</div><div class="line">                oPs[j].className =&apos;&apos;;</div><div class="line">            &#125;</div><div class="line">            this.className=&apos;cur&apos;;</div><div class="line">            oPs[this.joo].className = &apos;cur&apos;;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure></p>
<p><img src="/images/javascript/作用域选项卡.png"></p>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>JS中this当前行为主体</p>
<p>1、全局中的this是window</p>
<p><strong>主要研究函数的this</strong></p>
<p>2、函数执行的时候方法中的this要看函数执行的时候前面有没有‘.’,如果前面有点 点前面是谁this就是谁 如果没有点就是window</p>
<p>3、自执行函数里面的this永远就是window</p>
<p>4、给元素绑定事件 事件触发的时候 里面的this 就是当前绑定事件的元素</p>
<p>5、定时器中的this也是window</p>
<p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">//事件中的this</div><div class="line">var btn = document.getElementByTagName(&apos;button&apos;)[0];</div><div class="line">var oDiv = document.getElementByTagName(&apos;div&apos;)[0];</div><div class="line"></div><div class="line">btn.onclick = function()&#123;</div><div class="line">    console.log(this);//btn</div><div class="line">    ff();</div><div class="line">&#125;;</div><div class="line">funtion ff()&#123;</div><div class="line">     console.log(this);//window</div><div class="line">&#125;</div><div class="line"></div><div class="line">//自执行函数中的this</div><div class="line">(function()&#123;</div><div class="line">   console.log(this);//window</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">function fe()&#123;</div><div class="line">   console.log(this); //window</div><div class="line">   (function()&#123;</div><div class="line">       console.log(this);//window</div><div class="line">   &#125;)()</div><div class="line">&#125;</div><div class="line">fe();</div><div class="line"></div><div class="line">var obj = &#123;</div><div class="line">    fn:(function()&#123;</div><div class="line">        console.log(this);//obj window</div><div class="line">        return function()&#123;</div><div class="line">            console.log(this);//obj</div><div class="line">        &#125;</div><div class="line">    &#125;)()</div><div class="line">&#125;;</div><div class="line">obj.fn()</div><div class="line"></div><div class="line">//普通函数中的this</div><div class="line">var obj = &#123;&#125;;</div><div class="line">function fn()&#123;</div><div class="line">   console.log(this);//window</div><div class="line">   return function()&#123;</div><div class="line">       console.log(this);//window</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">var ff = fn();</div><div class="line">ff();</div><div class="line">obj.ff = ff;</div><div class="line">obj.ff(); //obj</div></pre></td></tr></table></figure></p>
<h2 id="类的封装"><a href="#类的封装" class="headerlink" title="类的封装"></a>类的封装</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><ul>
<li>单例模式：把描述同一事物（或同一对象）属性或方法放在一个内存空间，起到分组的作用</li>
<li>即使属性名相同也互不影响</li>
<li>“模块化开发”：项目中 开发模块比较多的时候，多人协作 每个人负责一个模块 最终将代码合在一起</li>
<li>单例模式中把flightFn和traninFn称为“命名空间”<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">//对象数据作用</div><div class="line">var flightFn = &#123;</div><div class="line">    title:&apos;我的机票&apos;,</div><div class="line">    mess:&apos;欢迎你来到我的机票购票&apos;,</div><div class="line">    say:function()&#123;</div><div class="line">        alert(&apos;这个模块是&apos;+this.title+&apos;,&apos;+this.mess);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">flightFn.say();</div><div class="line">var trainFn =&#123;</div><div class="line">    title:&apos;我的火车票&apos;，</div><div class="line">    mess:&apos;欢迎你来到我的火车票购票&apos;，</div><div class="line">    say:function()&#123;</div><div class="line">        alert(&apos;这个模块是&apos;+this.title+&apos;,&apos;+this.mess);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">trainFn.say();</div><div class="line"></div><div class="line">//公共模块</div><div class="line">var uitls = &#123;</div><div class="line">    date:function()&#123;</div><div class="line">         console.log(new Date);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var flightTicket1 =&#123;</div><div class="line">    fn:function()&#123;</div><div class="line">       console.log(&apos;这是关于机票&apos;);</div><div class="line">    &#125;,</div><div class="line">    init:function()&#123;</div><div class="line">    //    flightTicket1.fn();</div><div class="line">         this.fn();//调用自己模块中的功能</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">flightTicket1.init();</div><div class="line">var busTicket = &#123;</div><div class="line">    fn:function()&#123;</div><div class="line">       console.log(&apos;这是关于汽车票&apos;);</div><div class="line">       uitls.date();//调用其他模块的功能</div><div class="line">    &#125;,</div><div class="line">    init:function()&#123;</div><div class="line">        this.fn();//调用自己模块中的功能</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">busTicket.init();</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><ul>
<li>单例模式：手工作业</li>
<li>工厂模式： 把实现 相同功能的代码 放到一个函数里面 减少冗余代码 =&gt;”函数封装”</li>
<li>‘高内聚低耦合’：减少页面中重复代码 提高代码重复利用率<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function presonInfo(name,sex,hobby)&#123;</div><div class="line">   var obj = &#123;&#125;;</div><div class="line">   obj.name = name;</div><div class="line">   obj.sex = sex;</div><div class="line">   obj.hobby  = hobby;</div><div class="line">   obj.say = function()&#123;</div><div class="line">       consoel.log(this.name+&apos;是一个&apos;+this.sex+&apos;,我喜欢吃&apos;+this.hobby);</div><div class="line">   &#125;;</div><div class="line">   return obj;</div><div class="line">&#125;</div><div class="line">var obj1 = personInfo(&apos;chenhui&apos;,&apos;girl&apos;,&apos;火锅&apos;);</div><div class="line">console.log(obj1);</div><div class="line">obj1.say();</div><div class="line">var obj2 = presonInfo(&apos;qiuyue&apos;,&apos;girl&apos;,&apos;海底捞&apos;);</div><div class="line">console.log(obj2);</div><div class="line">obj2.say();</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><ul>
<li>在很多语言中都有面向对象</li>
<li>对象是一个泛指 比如 自然界</li>
<li>类：对对象的具体细分 比如 植物类 动物类 人类</li>
<li>实例：类中某一个具体事务 比如 人</li>
<li>类的 封装 继承 多态</li>
<li>继承：子类继承父类</li>
<li>多态：多种形态（重载和重写）JS中没有重载 但有些类似</li>
<li>重写：子类重写父类<blockquote>
<ul>
<li>OOP 面向对象编程（Object Oriented Programming，OOP，面向对象程序设计）是一种计算机编程架构。</li>
<li>编程语言 C、C++、Java、PHP、.NET(dot net)、C#、ASP、ASP.NET、Python、Ruby、Go、VB、JavaScript…  =&gt;所有的编程语言都是面向对象开发的(C是面向过程的)</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><ul>
<li><p>构造函数目的 创建一个自定义类 并且创建这个类的实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function CreatePerson(name,age)&#123;</div><div class="line">  //执行之前浏览器默认会创建一个对象</div><div class="line">     var num =815;</div><div class="line">     this.name = name;</div><div class="line">     this.age = age;</div><div class="line">   //默认将这个对象返回</div><div class="line">&#125;</div><div class="line">var person1 = new CreatePerson(&apos;chenhui&apos;,22);//构造函数模式 执行 它的返回值就是这个类的实例</div><div class="line">var person2 = new CreatePerson(&apos;qiuyue&apos;,21);</div><div class="line"> //person1和person2 都是CreatePerson的实例</div><div class="line">console.log(person1);</div><div class="line">console.log(person2.name);</div><div class="line">var person = CreatePerson(&apos;hui&apos;,20);//普通函数执行</div><div class="line">console.log(preson1);</div><div class="line"></div><div class="line">//在类中的this.xxx是给 当前实例添加属性 类中的this是当前实例</div></pre></td></tr></table></figure>
</li>
<li><p>类本身也是函数 类都是函数数据类型</p>
</li>
<li>实例是对象数据类型</li>
</ul>
<h4 id="工厂模式和构造函数模式区别"><a href="#工厂模式和构造函数模式区别" class="headerlink" title="工厂模式和构造函数模式区别"></a>工厂模式和构造函数模式区别</h4><p> 1、工厂模式 普通函数执行 构造函数通过new 来执行 默认创建一个对象 将其返回作为这个类的实例</p>
<p>2、执行的时候形成一个私有作用域 -&gt;形参赋值 -&gt;预解释 -&gt;代码 从上到下执行【同】</p>
<p>3、不同 构造函数模式执行的时候 会默认创建一个对象 也就是默认返回的实例     工厂模式 自己手动创建</p>
<p>4、构造函数模式执行的时候 如果指定返回的 是一个引用数据类型那么返回的就是引用数据类型</p>
<h4 id="单例模式和构造模式"><a href="#单例模式和构造模式" class="headerlink" title="单例模式和构造模式"></a>单例模式和构造模式</h4><p>1、单例模式是我们以后项目开发中业务逻辑编写最常用的设计模式：在业务逻辑相对复杂的时候，我们会基于单例模式引入“发布订阅模式”、“promise模式”…</p>
<p>2、构造原型模式是我们以后项目中封装类库、组件、插件、框架最常用的设计模式</p>
<p>3、单例模式：解决了变量冲突，实现了分类分组，在单例模式中我们的对象名叫做“命名空间”：单例模式把实现和描述同一事物的属性和方法进行分类归纳，然后汇总的同一命名空间下，不同的命名空间不冲突</p>
<p>4、真实项目中我们实现模块化开发基本都采用单例模式</p>
<p>5、高级单例模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var utils =&#123;</div><div class="line">    remove:function()&#123;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var skinRender =(function()&#123;</div><div class="line">    var a = 12;</div><div class="line">    return&#123;</div><div class="line">        fn:funcion()&#123;</div><div class="line">            utils.remove();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>1、每一个函数数据类型（普通函数、类（内置类、自定义类））都天生自带一个属性：prototype，这个属性的属性值是一个对象数据类型的结果  Person.prototype =&gt;{}</p>
<p>2、prototype对应的对象中，有一个天生自带的属性：constructor（构造函数），这个属性的属性值指向的是当前函数本身  Person.prototype =&gt;(constructor：Person)</p>
<p>3、每一个对象数据类型（普通对象、实例、prototype、函数也是对象）都是一个天生自带的属性：<strong>proto</strong>,这个属性指向自己所属类的原型（prototype）</p>
<p>4、类的原型（prototype）上存储的属性和方法都是实例公有的属性方法</p>
<blockquote>
<p>5、javascript就是一种基于原型的语言</p>
<p>6、原型链：ECMAScript的描述的原型链的概念，并将原型链作为实现继承的方法，其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。javascript原型链：</p>
</blockquote>
<p><img src="/images/javascript/原型链.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">function Preson(name)&#123;</div><div class="line">    //this.xxx = xxx 都是实例的私有属性</div><div class="line">    this.name = name;</div><div class="line">    this.say = function()&#123;</div><div class="line">        console.log(&apos;my name is&apos;+ this.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">var p1 = new Preson(&apos;卉&apos;);</div><div class="line">var p2 = new Preson(&apos;陈&apos;);</div><div class="line"></div><div class="line"></div><div class="line"> //原型上写的属性都是实例的公有属性</div><div class="line">Person.prototype.drink = function()&#123;</div><div class="line">       console.log(&apos;cheers!&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log(p1.say === p2.say);//-&gt;false</div><div class="line">console.log(p1.drink ===p2.drink);//-&gt;true</div><div class="line">//-&gt;hasOwnProperty:检测属性是否为对象（实例）的私有属性-&gt;true</div><div class="line">console.log(p1.hasOwnProperty(&apos;drink&apos;));</div><div class="line">//-&gt;in:不管当前的属性是私有的还是公有的，只要有返回的结果就是true</div><div class="line">console.log(&apos;drink&apos; in p1);//true</div><div class="line"></div><div class="line">p1.drink();//-&gt;先找自己私有属性，如果私有的属性中没有drink，则继续到所有类的原型上查找...一直找到Object.prototype为止 =&gt;这种查找的机制叫做“原型链”</div><div class="line"></div><div class="line">p1.__proto__.drink();//-&gt;跳过私有的查找，直接的找到原型上的公有属性</div><div class="line"></div><div class="line">p1.hasOwnProperty();//-&gt;this指向p1</div><div class="line"></div><div class="line">p1.__proto__.hasOwnProperty();//-&gt;this指向p1.__proto__(Person.prototype)</div><div class="line"></div><div class="line">p1.__proto__.__proto__.hasOwnProperty();//-&gt;this指向p1.__proto__.__proto__(Object.prortotype)   ===&gt;Object.prototype.hasOwnProperty()===&gt;让Object原型上的hasOwnProperty方法执行</div><div class="line">//通过以上三种办法，我们都可以把hasOwnProperty方法执行，但是有所区别：方法执行的时候，方法中的this是不一样的；在万恶的ie浏览器下，为了保护原型，屏蔽了我们使用__proto__这个属性</div></pre></td></tr></table></figure>
<h3 id="原型进阶"><a href="#原型进阶" class="headerlink" title="原型进阶"></a>原型进阶</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var ary = [13,24,27,56,89];</div><div class="line">var newAry = ary.sort(function(a,b)&#123;</div><div class="line">    return a - b;</div><div class="line">&#125;);</div><div class="line">// console.log(ary);//-&gt;会把原数组改变</div><div class="line">// console.log(newAry);//-&gt;也有返回值，返回的结果是改变后的数组</div><div class="line">newAry = newAry.slice(0,3);</div><div class="line">console.log(newAty);</div></pre></td></tr></table></figure>
<h3 id="原型进阶—链式写法"><a href="#原型进阶—链式写法" class="headerlink" title="原型进阶—链式写法"></a>原型进阶—链式写法</h3><p>链式写法：需要保证每一执行方法返回的结果依然是当前类的一个实例，这样就可以继续调取原型上的方法了…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var ary = [13,24,27,56,89];</div><div class="line">ary.sort(function(a,b)&#123;</div><div class="line">   return a - b;</div><div class="line">&#125;).slice(0,3).reverse().push(100).pop();//-&gt;Uncaught TypeError: ary.sort(...).slice(...).reverse(...).push(...).pop is not a function 执行push方法后，返回的结果是新增后数组的长度，是一个数字，不能再继续调取Array.prototype上的方法了</div><div class="line"></div><div class="line">Array.prototype.mySlice = function mySlice()&#123;</div><div class="line">     return this;//-&gt;实现链式写法最简单的方式，就是在每一个方法执行完成后返回this即可，因为方法找中的this就是当前类的实例</div><div class="line">&#125;;</div><div class="line">ary.mySlice().push();</div></pre></td></tr></table></figure>
<h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><blockquote>
<p>所有的对象数据类型（普通函数 实例 原型…）都是Object的一个实例</p>
</blockquote>
<ul>
<li>所有函数数据类型（普通函数 类（自定义 内置），都是Function这个类的实例）</li>
<li>所有实例都是对象数据类型的 函数也是对象数据类型的</li>
<li>对象数据类型都有一个天生自带的属性<strong>proto</strong>指向所属类的原型</li>
<li>因为 函数也是对象数据类型的 我们Function（内置类）它也是函数数据类型 所以它也是对象数据类型的 每一个对象数据类型都有一个天生自带的属性<strong>proto</strong>。</li>
<li>Function是一个内置类 类都是函数数据类型 所有函数数据类型 都是Function这个内置类的实例 所以Function作为一个类 一个 对象数据类型，它的<strong>proto</strong>指向所属类的原型 Function的prototype也就是Function自己的prototype</li>
<li>Object是一个基类 JS中最顶层的类，类都是函数数据类型函数也是对象数据类型函数 那么Object也有一个天生自带的属性<strong>proto</strong>,因为Object也是函数数据类型 它的<strong>proto</strong>指向Function的prototype</li>
</ul>
<h3 id="函数多面性"><a href="#函数多面性" class="headerlink" title="函数多面性"></a>函数多面性</h3><p>1、普通函数</p>
<p>执行的时候可以形成私有作用域，形参赋值 预解释 代码从上到下执行</p>
<p>2、作为一个类</p>
<p>具有原型链模式 类和实例的概念</p>
<p>3、作为一个普通对象</p>
<p>当做一个对象给它添加属性</p>
<h2 id="call-方法"><a href="#call-方法" class="headerlink" title="call 方法"></a>call 方法</h2><p>1、所有的函数数据类型（普通函数 类（内置 自定义））都是Function的一个实例</p>
<p>2、每一函数都可以使用Function的prototype上的存储的属性和方法</p>
<p>3、Function的prototype上 比较常用的（call/apply/bind(有兼容性)）方法</p>
<p>4、fn.call每一个函数都通过自己<strong>proto</strong>找到Function原型上的call方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">console.dir(Function);</div><div class="line">function fn()&#123;</div><div class="line">   console.log(this);</div><div class="line">&#125;</div><div class="line">console.log(fn.call === fn.__proto__.call);</div><div class="line">console.log(fn.call === Function.prototype.call);</div><div class="line">console.log(fn.__proto__.call === Function.prototype.call);</div><div class="line">fn.call();//fn();</div><div class="line">//fn.call(obj) 这里面fn是call的this，call方法让它的this执行也就是fn()并且将fn中的this修改为call的第一个参数值obj，所以 此时fn中的this被修改为obj</div></pre></td></tr></table></figure>
<h3 id="call的作用"><a href="#call的作用" class="headerlink" title="call的作用"></a>call的作用</h3><p>1、让call方法中的this 当做一个函数执行【改变call‘.’前面方法中的this，并让前面的方法执行】</p>
<p>2、将call的this中的this修改为call的第一个参数值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;info:&apos;say&apos;&#125;;</div><div class="line">var info = &apos;sayHi&apos;;</div><div class="line">function fn()&#123;//因为fn是call方法的this call将fn中this修改为了第一个参数值obj this-&gt;obj</div><div class="line">   console.log(this.info);//obj.info</div><div class="line">&#125;</div><div class="line">fn.call(obj);//call中this -&gt;fn()-&gt; 将fn中的this 修改为call(obj)call中第一参数值obj</div><div class="line">fn();//如果这样执行 fn中的this是window</div></pre></td></tr></table></figure>
<h3 id="call语法"><a href="#call语法" class="headerlink" title="call语法"></a>call语法</h3><p>函数.call([this],param1,param2…) 第一个参数作为call的this中this 其余后面依次是在给call的this里面传递的参数值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;info:&apos;say&apos;&#125;;</div><div class="line">function fn(a,b)&#123;</div><div class="line">     console.log(this);//Object</div><div class="line">     console.log(a,b);//10,20</div><div class="line">&#125;</div><div class="line">fn.call(obj,10,20);</div></pre></td></tr></table></figure></p>
<h3 id="严格模式或非严格模式下的call"><a href="#严格模式或非严格模式下的call" class="headerlink" title="严格模式或非严格模式下的call"></a>严格模式或非严格模式下的call</h3><p>‘use strict’</p>
<p>‘严格模式’让Javascript在更加严格的方式下运行</p>
<p>call作用 就是改变方法中的this关键字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var arr = [1,2,3];</div><div class="line">function fn()&#123;</div><div class="line">   console.log(this);</div><div class="line">&#125;</div><div class="line">fn.call();</div><div class="line">fn.call(null);</div><div class="line">fn.call(undefined);</div><div class="line">fn.call(arr);</div></pre></td></tr></table></figure></p>
<p>非严格模式 如果call中第一个参数不传或者传的是null/undefined,方法中this都是window，其余的call中第一个参数是啥就是啥</p>
<p>在严格模式下 如果call中第一参数不传就是undefined，其余的call中第一个参数就是啥就是啥 如果是null就是null，如果是undefined就是undefined</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function fn(a,b)&#123;</div><div class="line">console.log(this);</div><div class="line">console.log(a,b);</div><div class="line">&#125;</div><div class="line">fn.call(null,100,200);//this是 number 100 把200当做第一个实参 传递给 fn中的第一个形参</div></pre></td></tr></table></figure>
<blockquote>
<p>call 还可以实现继承</p>
<h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><p>apply 修改方法中的this关键字</p>
</blockquote>
<p>作用：将apply ‘.’前面的this修改call中的第一个参数值，并让apply‘.’前面的this执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var arr1 = [1,2,3];</div><div class="line">var arr2 = [3,4,5];</div><div class="line">function fn(a,b)&#123;</div><div class="line">   console.log(this);</div><div class="line">   console.log(a,b);</div><div class="line">&#125;</div><div class="line">fn.call(arr1,100,200);</div><div class="line">fn.apply(arr2);//首先fn是apply的this 将fn中的this改为arr2并让 fn执行</div><div class="line">fn.apply(arr1,[100,200]);</div></pre></td></tr></table></figure></p>
<h3 id="call和apply的区别"><a href="#call和apply的区别" class="headerlink" title="call和apply的区别"></a>call和apply的区别</h3><p>首先call和apply都是改变方法中的this关键字</p>
<p>区别：call传参的时候是从第二参数开始一个一个的传递</p>
<pre><code>apply把需要传递的参数值 放在一个数组里，也相当于一个一个将参数传递进去
</code></pre><h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><p>当参数明确是可以用call，当参数不明确是可用apply结合arguments<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">print.call(window,&quot;背&quot;,&quot;光&quot;,&quot;脚&quot;,&quot;本&quot;);</div><div class="line">//foo参数可能多个</div><div class="line">function foo()&#123;</div><div class="line">print.apply(window,arguments);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="bind-IE-6-8"><a href="#bind-IE-6-8" class="headerlink" title="bind (IE 6-8)"></a>bind (IE 6-8)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">var fe = fn.bind(arr1);</div><div class="line">//预处理：事先将fn中的this修改为arr1 但并不会让fn执行，而是将改造后的fn当做返回值返回</div><div class="line">//用的时候在执行</div><div class="line">var arr1 = [1,2,3];</div><div class="line">var arr2 = [3,4,5];</div><div class="line">function fn(a,b)&#123;</div><div class="line">   console.log(this);</div><div class="line">   console.log(a,b);</div><div class="line">&#125;</div><div class="line">// fn.call(arr1);</div><div class="line">var fe = fn.bind(arr1,100,200);//fe接收的是this被改造后的fn</div><div class="line">fe();//改造后的fn执行</div><div class="line">   //call/apply第一个参数指定谁方法中this是谁</div><div class="line"></div><div class="line"></div><div class="line">function fn1()&#123;</div><div class="line">   console.log(&apos;fn1&apos;);</div><div class="line">&#125;</div><div class="line">function fn2()&#123;</div><div class="line">   console.log(&apos;fn2&apos;);</div><div class="line">&#125;</div><div class="line">window.fn1.call(fn2);//让fn1执行将里面this修改为fn2</div><div class="line">//call‘.’前面的方法执行</div><div class="line">//然后让‘.’前面的方法里面的this 改为call中第一个参数 fn2</div><div class="line">fn1.call.call.call.call()每一个函数都可以使用Function.prototype上的call方法 因为call也是要给函数 所以就可以fn1.call.call.call.call</div><div class="line">fn1.call(fn2);//fn1()把里面this变为fn2</div><div class="line">fn1.call.call(fn2);</div></pre></td></tr></table></figure>
<h3 id="多个call"><a href="#多个call" class="headerlink" title="多个call"></a>多个call</h3><p>规律：两个call以上最终执行的是 最后一个call中的第一个参数  里面this是window<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">var obj =&#123;</div><div class="line">     fn: function()&#123;</div><div class="line">         console.log(this);//fn2</div><div class="line">         console.log(&apos;fn&apos;);</div><div class="line">     &#125;</div><div class="line">&#125;;</div><div class="line">// obj.fn.call(fn2);//让obj.fn执行 并且将里面的this改为 fn2 obj.fn =&gt; fn2.fn()</div><div class="line">function fn1()&#123;</div><div class="line">    console.log(&apos;fn1&apos;);</div><div class="line">&#125;</div><div class="line">function fn2()&#123;</div><div class="line">    console.log(&apos;fn2&apos;);</div><div class="line">&#125;</div><div class="line">//  fn1.call.call(fn2);</div><div class="line">    fn1.call.call.call.call(fn2);</div><div class="line">    //让fn1.call执行 将第一个call前面的fn1变成了fn2  fn1.call()变成了fn2.call()</div><div class="line">    //并且让fn2.call()执行 让fn2执行 里面this默认为window</div><div class="line">    //最终执行的就是我们fn2() 然后输出‘fn2’</div><div class="line"></div><div class="line">    //最后一个call先执行 最后一个call的目的 让fn1.call执行 并且将里面的this改为 fn2 相当于 fn1.call() =&gt; fn2.call()</div><div class="line">    //fn2.call()让fn2执行并且将里面的this改成window</div><div class="line">    //最终fn2执行输出‘fn2’；</div></pre></td></tr></table></figure></p>
<h2 id="try-catch-js中比较常用的捕获异常方法"><a href="#try-catch-js中比较常用的捕获异常方法" class="headerlink" title="try catch js中比较常用的捕获异常方法"></a>try catch js中比较常用的捕获异常方法</h2><p>try catch finally</p>
<p>如果try里面报错就执行catch里面的代码</p>
<p>catch(e).message 报错信息</p>
<p>finally不管上面报不报错 都会执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">try&#123;</div><div class="line">   console.log(num);</div><div class="line">&#125;catch(e)&#123;</div><div class="line">   console.log(e.message);</div><div class="line">   //throw new Error(e.message);//让浏览器抛出异常</div><div class="line">&#125;</div><div class="line">console.log(123);</div></pre></td></tr></table></figure>
<h2 id="arguments是一个类数组-但是也可以像数组一样可以循环遍历"><a href="#arguments是一个类数组-但是也可以像数组一样可以循环遍历" class="headerlink" title="arguments是一个类数组 但是也可以像数组一样可以循环遍历"></a>arguments是一个类数组 但是也可以像数组一样可以循环遍历</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">//利用数组中的slice方法将类数组转化为数组，只需要改变slice中this即可</div><div class="line">Array.prototype.slice.call(arguments,0)</div><div class="line">[].slice.call(arguments,0)</div><div class="line"></div><div class="line">//求平均数</div><div class="line">// arguments 实参集合 类数组 它也不是数组 不是Array的实例所以不能直接使用 数组sort的方法</div><div class="line">function average()&#123;</div><div class="line">    var arr =[].slice.call(arguemnts,0);//让slice方法中操作的this指向我们的arguments</div><div class="line">    arr.sort(function(a,b)&#123;</div><div class="line">        return a-b;</div><div class="line">    &#125;);//排序</div><div class="line">    arr.shift();//shift 删除数组开头第一项 返回的删除的内容 原数组改变</div><div class="line">    arr.length--;</div><div class="line">    var sum = eval(arr.join(&apos;+&apos;));</div><div class="line">    var num = (sum/arr.length).toFixed(2);</div><div class="line">    return num;</div><div class="line">&#125;</div><div class="line">var argNum = average(9,2,8,9,10,7,6);</div><div class="line">cosole.log(argNum);</div><div class="line"></div><div class="line">//用slice将类数组转化为数组时 由于DOM元素集合在Ie6-8中不兼容 所以我们不能用</div><div class="line">//js中如果当前代码报错 不处理的情况下 后面代码不会执行</div><div class="line">//利用异常捕获方法</div><div class="line">var lis = document.getElementByTagName(&apos;li&apos;);//获取所有li</div><div class="line">//类数组为数组</div><div class="line">function listToArray(list)&#123;</div><div class="line">    try&#123;</div><div class="line">        return [].slice.call(list,0)</div><div class="line">    &#125;catch (e)&#123;</div><div class="line">        var arr = [];</div><div class="line">        for(var i=0; i&lt;list.length;i++)&#123;</div><div class="line">               arr.push(list[i]);</div><div class="line">        &#125;</div><div class="line">        return arr;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">console.log(listToArray(lis));</div></pre></td></tr></table></figure>
<h2 id="求数组中最大值和最小值"><a href="#求数组中最大值和最小值" class="headerlink" title="求数组中最大值和最小值"></a>求数组中最大值和最小值</h2><p>1、利用排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var arr = [10,20,11,12,9,15];</div><div class="line">//先排序 从小到大 取出第一项（min）和最后一项（max）</div><div class="line">arr.sort(function(a,b)&#123;</div><div class="line">       return a - b;</div><div class="line">&#125;);</div><div class="line">console.log(arr);</div><div class="line">var max = arr[arr.length - 1];</div><div class="line">var min = arr[0];</div></pre></td></tr></table></figure></p>
<p>2、假设法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//先取出第一项作为基准点 假设第一项是最大 然后用数组剩余项分别和这个基准点进行比较，如果数组中当前项 比我这个基准点还要大，我们就让当前项在做为我们的基准点 一直比较下去</div><div class="line">var arr = [10,20,11,12,9,15];</div><div class="line">var max = arr[0]; //假设数组中第一项是最大的</div><div class="line">var min = arr[0];</div><div class="line">for(var i = 1;i&lt;arr.length;i++)&#123; //拿出数组中剩余的每一项和max进行比较</div><div class="line">        var cur = arr[i];</div><div class="line">        // 20 &gt; 10? max = 20 : null;</div><div class="line">        cur &gt; max ? max = cur : null;//谁大就让max等于谁</div><div class="line">        cur &lt; min ? min = cur : null;//谁下就让max等于谁</div><div class="line">&#125;</div><div class="line">console.log(max,min);// 20 9</div></pre></td></tr></table></figure></p>
<p>3、Math.min/Math.max 比较一堆数中的最小值和最大值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var min = Math.min(10,20,11,12,9,15);</div><div class="line">var max = Math.max(10,20,11,12,9,15);</div><div class="line">var min = Math.min([10,20,11,12,9,15]);</div><div class="line">var max = Math.max([10,20,11,12,9,15]);</div></pre></td></tr></table></figure></p>
<p>4、利用apply传递参数的时候 是把需要的参数放在数组里 其实也上相当于一次性分别把数组中的每一个参数取出来 当作实参传递到我们方法中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var arr =[10,20,11,12,9,15];</div><div class="line">// var max = Math.max(eval(arr.toSting()));</div><div class="line">//利用Math的方法取出最大值</div><div class="line">var max =Math.max.apply(null,[10,20,11,12,9,15])</div><div class="line">var min =Math.min.apply(null,[10,20,11,12,9,15])</div><div class="line">console.log(max.min);</div></pre></td></tr></table></figure></p>
<h2 id="DOM映射"><a href="#DOM映射" class="headerlink" title="DOM映射"></a>DOM映射</h2><p>DOM映射：html页面中的元素 和 JS中通过DOM方法获取的元素对象 是绑定在一起的 一一对应的   一个改变另一个也会改变</p>
<p>HTMLCollection/NodeList: 元素集合/节点集合 即时更新，如果所属的内部结构发生了改变 它会自动同步更新<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">&lt;ul&gt;</div><div class="line">  &lt;li&gt;111&lt;/li&gt;</div><div class="line">  &lt;li&gt;222&lt;/li&gt;</div><div class="line">  &lt;li&gt;333&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div><div class="line">&lt;script&gt;</div><div class="line">var uls = document.getElementByTagName(&apos;ul&apos;)[0];</div><div class="line">var lis = uls.getElementByTagName(&apos;li&apos;);</div><div class="line">lis[1].style.backgroundColor = &apos;red&apos;;</div><div class="line">setTimeout(function()&#123;</div><div class="line">//uls.appendChild(lis[1]);//本身页面中已有的 在appendChild 等于 移动元素到容器末尾</div><div class="line">var list = document.creatElement(&apos;li&apos;);</div><div class="line">// list.innerHTML = &apos;hello&apos;;</div><div class="line">// uls.appendChild(lis[1]);//本身页面中已有的 在appendChild 等于移动元素到容器末尾</div><div class="line">        var list = document.createElement(&apos;li&apos;);</div><div class="line">        //list.innerHTML = &apos;hello&apos;;</div><div class="line">        //uls.appendChild(list);</div><div class="line">        uls.insertBefore(lis[2],lis[0]);</div><div class="line">&#125;,2000);</div><div class="line"> //HTMLCollection: 元素集合 即使更新 如果内部结构发生改变 会更新同步元素集合中</div><div class="line"> console.log(lis);</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure></p>
<p>DOM回流：页面中html结构发生改变（增加、删除、位置改变），浏览器就会重新计算一次DOM结构</p>
<p>动态创建 多次操作DOM(appendChild)就会引起多次回流 耗费性能</p>
<p>字符串拼接是把所有拼接好的 最终一次输出到页面，只引发一次回流</p>
<p>重绘：页面中部分样式发生改变(背景颜色，字体颜色)，浏览器只会把这个改变的元素重新渲染</p>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>JSON:一种数据格式，主要应用于后端交互，前台向后台发送请求时 后台返回的基本是JSON格式的数据<br>JSON对象 JSON字符串</p>
<p>1、JSON对象 和js对象类似 但是属性名必须用’””‘包起来，属性值如果是字符串也要双引号包起来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var obj1 = &#123;name: &apos;chenhui&apos;, &quot;age&quot;: 22&#125;; // 普通JS对象</div><div class="line">var obj2 = &#123;&quot;name&quot;: &quot;chenhui&quot;, &quot;age&quot;: 22&#125;; // JSON对象</div><div class="line">var arr = [</div><div class="line">        &#123;&quot;name&quot;: &quot;chenhui&quot;, &quot;age&quot;: 22&#125;,</div><div class="line">        &#123;&quot;name&quot;: &quot;chenhui&quot;, &quot;age&quot;: 22&#125;,</div><div class="line">        &#123;&quot;name&quot;: &quot;chenhui&quot;, &quot;age&quot;: 22&#125;</div><div class="line">    ];</div></pre></td></tr></table></figure></p>
<p>2、JSON字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var jsonStr1 = &apos;&#123;&quot;name&quot;: &quot;chenhui&quot;, &quot;age&quot;: 22&#125;&apos;;</div><div class="line">var jsonStr2 = &apos;[&#123;&quot;name&quot;: &quot;chenhui&quot;, &quot;age&quot;: 22&#125;]&apos;;</div></pre></td></tr></table></figure></p>
<p>3、window浏览器对象上有一个JSON属性对象</p>
<p>提供了两个方法：</p>
<p>(1)、JSON.parse：用来将JSON格式的字符串转化为JSON格式对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var jStr1 = JSON.parse(jsonStr1);</div><div class="line">var jStr2 = JSON.parse(jsonStr2);</div><div class="line">console.log(jsonStr2);</div><div class="line">JSON.parse(&apos;&#123;&quot;name&quot;:&quot;chenhui&quot;,&quot;age&quot;:22&#125;&apos;);</div><div class="line">JSON.parse(&apos;[&#123;&quot;name&quot;:&quot;chenhui&quot;,&quot;age&quot;:22&#125;]&apos;);</div><div class="line">JSON.parse(&apos;[&#123;&quot;name&quot;:&quot;chenhui&quot;,&quot;info&quot;:&quot;web前端工程师&quot;&#125;]&apos;);</div></pre></td></tr></table></figure></p>
<p>(2)、JSON.stringify: 将普通格式对象/JSON格式的对象转换为JSON格式字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var objs = &#123;name: &apos;chenhui&apos;, info: &apos;web前端工程师&apos;&#125;;</div><div class="line">var jObj = &#123;&quot;name&quot;: &quot;chenhui&quot;, &quot;info&quot;: &quot;web前Duang工程师&quot;&#125;;</div><div class="line">var Obj1 = JSON.stringify(objs);</div><div class="line">var Obj2 = JSON.stringify(jObj);</div><div class="line">JSON.stringify(&#123;&quot;name&quot;: &quot;chenhui&quot;, &quot;info&quot;: &quot;web前端工程师&quot;&#125;);</div><div class="line">JSON.stringify(&#123;name: &apos;chenhui&apos;, info: &apos;web前端工程师&apos;&#125;);</div><div class="line">console.log(Obj1);</div><div class="line">console.log(typeof Obj1);</div><div class="line">console.log(Obj2);</div><div class="line">console.log(typeof Obj2);</div></pre></td></tr></table></figure></p>
<p>(3)、JSON在ie7以下 不兼容 就需要使用eval<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">eval(&apos;(&#123;&quot;name&quot;: &quot;chenhui&quot;,&quot;age&quot;: 22&#125;)&apos;);</div><div class="line">var json1 = &apos;&#123;&quot;name&quot;: &quot;chenhui&quot;,&quot;age&quot;: 22&#125;&apos;;</div><div class="line">var data = eval(&apos;(&apos; + json1 + &apos;)&apos;);</div><div class="line">console.log(data);</div></pre></td></tr></table></figure></p>
<p>(4)、处理兼容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var json1 = &apos;&#123;&quot;name&quot;: &quot;chenhui&quot;,&quot;age&quot;: 10&#125;&apos;;</div><div class="line">    &quot;JSON&quot; in window ? JSON.parse(json1) : eval(&apos;(&apos; + json1 + &apos;)&apos;);</div></pre></td></tr></table></figure></p>
<blockquote>
<p>eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。该方法只接受原始字符串作为参数，如果 string 参数不是原始字符串，那么该方法将不作任何改变地返回。因此请不要为 eval() 函数传递 String 对象来作为参数。</p>
</blockquote>
<h2 id="字符串拼接和动态创建【dom节点或dom元素】"><a href="#字符串拼接和动态创建【dom节点或dom元素】" class="headerlink" title="字符串拼接和动态创建【dom节点或dom元素】"></a>字符串拼接和动态创建【dom节点或dom元素】</h2><ul>
<li><p>动态添加<br> 文档碎片 动态创建的一个容器 通常用来避免多次回流</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//创建文档碎片</div><div class="line">var frg = document.createDocumentFragment()</div></pre></td></tr></table></figure>
<ul>
<li>优点 不会影响原有的 事件和效果</li>
<li>缺点 引发多次回流</li>
</ul>
</li>
<li>字符串添加拼接<ul>
<li>优势：只会引发一次回流</li>
<li>弊端：当我们在往原有的里面拼接添加的时候 相当于想把原有的当做字符串获取到然后再和新生成拼接成字符串 在输出，这样浏览器会重新渲染和解析 从而导致原有的事件和效果失效</li>
</ul>
</li>
</ul>
<h2 id="ajax数据【简单交互】"><a href="#ajax数据【简单交互】" class="headerlink" title="ajax数据【简单交互】"></a>ajax数据【简单交互】</h2><p>ajax = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</p>
<p>ajax:异步请求 局部刷新【ajax的最大特点】</p>
<p>优点：通过AJAX，JavaScript 无需等待服务器的响应，而是：</p>
<ul>
<li>在等待服务器响应时执行其他脚本</li>
<li>当响应就绪后对响应进行处理</li>
</ul>
<p>1、创建 XMLHttpRequest 对象（IE5 和 IE6 使用 ActiveXObject）</p>
<ul>
<li>XMLHttpRequest 对象用于和服务器交换数据。</li>
</ul>
<p>2、（1）、要发送请求</p>
<ul>
<li><p>@param1 获取方式（method）请求方式 get post<br>get与post相比，get更简单也更快，并且大部分情况下都能用<br>以下情况中，使用用post请求</p>
<ul>
<li>无法使用缓存文件（更新服务器上的文件或数据库）</li>
<li>向服务器发送大量数据（POST没有数据量限制）</li>
<li>发送包含未知字符的用户输入时，POST比GET更稳定也更可靠</li>
</ul>
</li>
<li><p>@param2 请求地址（url） ‘./data.txt’</p>
</li>
<li><p>@param3:（async） true 默认就是异步请求  false 同步</p>
<p>（2）、监听请求响应（还需要判断是否请求成功 是否拿到数据）</p>
<p>onreadystatechange 事件<br>当请求被发送到服务器时，我们需要执行一些基于响应的任务。</p>
<p>每当readyState改变时，就会触发onreadysatechange事件。</p>
<p>readyState属性存有XMLHttpRequest的状态信息。XMLHttpRequest对象的三个重要的属性：</p>
<p>onreadystatechange 存储函数（或函数名），每当readyState属性改变时，就会调用该函数。</p>
</li>
<li><p>readyState: 0,1,2,3,4    ajax 状态码</p>
<ul>
<li>0：请求未初识化</li>
<li>1：服务器连接已建立</li>
<li>2：请求已接收</li>
<li>3：请求处理中</li>
<li>4：请求已完成，且响应已就绪</li>
</ul>
</li>
<li>status http请求状态码<ul>
<li>200：”OK”</li>
<li>404：未找到页面<br>3、发送 send()<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var xhr = new XMLHttpRequest;//生成一个XMLHttpRequest的实例 在这个实例里面提供了发送请求和接收数据的 属性方法</div><div class="line">console.log(xhr);</div><div class="line">xhr.open(&apos;get&apos;,&apos;./data.txt&apos;,true);</div><div class="line">xhr.onreadystatechange = function()&#123;</div><div class="line">//如果是4的话说明成功完成发送请求 如果http请求成功状态码基本是200 一些2开头三位数也代表成功；通常访问一个不存在的网页返回的http状态码 404</div><div class="line">     if(this.readyState === 4&amp;&amp; this.status == 200)&#123;</div><div class="line">        console.log(xhr.responseText);</div><div class="line">        console.log(typeof xhr.responseText);</div><div class="line">     &#125;</div><div class="line">&#125;;</div><div class="line">//发送</div><div class="line">xhr.send();</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>可以使用Callback【回调】函数</p>
</blockquote>
<p>callback 函数是一种以参数形式传递给另一个函数【ajax请求总共有多少种callback】</p>
<h3 id="ajax-可以用来与XML文件进行交互通信【高级】"><a href="#ajax-可以用来与XML文件进行交互通信【高级】" class="headerlink" title="ajax 可以用来与XML文件进行交互通信【高级】"></a>ajax 可以用来与XML文件进行交互通信【高级】</h3><p>loadXMLDoc() 函数创建 XMLHttpRequest 对象，添加当服务器响应就绪时执行的函数，并将请求发送到服务器。</p>
<p>当服务器响应就绪时，会构建一个 HTML 表格，从 XML 文件中提取节点（元素），最后使用已经填充了 XML 数据的 HTML 表格来更新 txtCDInfo 占位符</p>
<p>responseXML    获得 XML 形式的响应数据。</p>
<p>通过XMLHTTP加载XML文件</p>
<p><img src="/images/javascript/简单交互过程.png"></p>
<h2 id="正则-regular-expression"><a href="#正则-regular-expression" class="headerlink" title="正则(regular expression)"></a>正则(regular expression)</h2><p>正则表达式是用来处理字符串的，它的特长在于处理复杂的字符串</p>
<p>1、正则定义了一个字符串的模型</p>
<p>2、正则的第一个作用是“验证某字符串是否和这个模型相匹配”。</p>
<p>3、正则的第二作用是“把匹配到的内容找出来”</p>
<p>正则就是由相关‘元字符’和‘修饰符’组成的一个规则，用来匹配、验证或捕获字符串中某些内容的规则（正则仅仅是用来处理字符串的）</p>
<blockquote>
<ul>
<li>元字符</li>
<li>修饰符</li>
<li>编写常用的正则</li>
<li>正则的验证</li>
<li>正则的捕获</li>
<li>正则的方法的封装</li>
</ul>
</blockquote>
<h3 id="定义正则"><a href="#定义正则" class="headerlink" title="定义正则"></a>定义正则</h3><p>1、创建正则的两种方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var reg = /abcd/;  //对象直接量方法</div><div class="line">var reg = new RegExp(&apos;abcd&apos;)  //这个叫构造函数方式</div></pre></td></tr></table></figure></p>
<p>2、如果有模式修正符，比如上全文查找abcd这个字符串，两种写法分别是(g是模式修正符，表示在整个字符串里面多次查找)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var  reg = /abcd/g;</div><div class="line">var reg = newu RegExp(&apos;abcd&apos;,&apos;g&apos;);</div></pre></td></tr></table></figure></p>
<p>3、有一种情况要注意，就是如果正则中出现了斜杠“\”(回车上边的斜杠)，在用构造函数创建正则对象时，要转义，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">reg = new RegExp(&quot;\\w+&quot;) //这里的\要转义</div><div class="line">reg = /\w+/   //这样就不需要</div></pre></td></tr></table></figure></p>
<h3 id="正则的元字符"><a href="#正则的元字符" class="headerlink" title="正则的元字符"></a>正则的元字符</h3><blockquote>
<p>只要在“/元子符/”之间包含起来的，都是正则的元字符</p>
</blockquote>
<ul>
<li>特殊元子符<ul>
<li>\ 转义字符（把有意义和没意义的字符来回转）</li>
<li>.除了\n以外的任意字符</li>
<li>\n 换行符</li>
<li>^ 以xxx开始</li>
<li>$ 以xxx结束</li>
<li>\d 匹配0-9之间的任意数字 \D：除了0-9之间数字的任意字符</li>
<li>\b 匹配一个边界</li>
<li>\w 匹配数字、字母、下划线中的任意字符。等价于’[A-Za-z0-9]’。\W 匹配包括下划线</li>
<li>\s 匹配一个空白字符</li>
<li>[xyz] x或者y或者z中的一个，例如：[abcd]四个字母中的任意一个</li>
<li>[^xyz] 除了三个以外的任意字符</li>
<li>[a-z] 匹配a-z中的任意字符</li>
<li>[^a-z] 匹配除了a-z中的任意字符</li>
<li>x|y 匹配x或者y中的任意一个</li>
<li>() 分组</li>
<li>?: 只匹配不捕获</li>
<li>?= 正向预查</li>
<li>?! 负向预查 两个预查也起到了只匹配不捕获的作用</li>
<li>…</li>
</ul>
</li>
<li>量词元字符<ul>
<li>* 出现零次或者多次</li>
<li>？ 出现零次或者一次</li>
<li>+ 出现一次或者多次</li>
<li>{n} 出现n次</li>
<li>{n,} 出现n到多次</li>
<li>{n,m} 出现n到m次</li>
</ul>
</li>
<li>普通云字符：代表本身意思的元字符</li>
</ul>
<h3 id="正则的修饰符（img）"><a href="#正则的修饰符（img）" class="headerlink" title="正则的修饰符（img）"></a>正则的修饰符（img）</h3><ul>
<li>i: ignoreCase 忽略大小写</li>
<li>m: multiline 匹配换行</li>
<li>g: global 全局匹配</li>
</ul>
<h3 id="test-正则的方法，验证某一个字符串是否符合某一个规则的"><a href="#test-正则的方法，验证某一个字符串是否符合某一个规则的" class="headerlink" title="test 正则的方法，验证某一个字符串是否符合某一个规则的"></a>test 正则的方法，验证某一个字符串是否符合某一个规则的</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">var str =&apos;chenhui1995qiuyue2017&apos;;</div><div class="line">var reg = /\d+/; //-&gt;只要“包含连续出现一个多个数字”这个规则就可以</div><div class="line">console.log(reg.test(str));//-&gt;TRUE</div><div class="line">reg = /^\d+$/; //-&gt;以数字开头，以数字结尾，中间是数字（只能是数字）</div><div class="line">console.log(reg.test(str)); //-&gt;FALSE</div><div class="line"></div><div class="line">//表单验证： 验证用户输入的内容是否既定的格式（常用的正则）</div><div class="line"></div><div class="line">//1、手机号  11位数字 以1开头</div><div class="line">var reg =  /^1\d&#123;10&#125;$/;</div><div class="line"></div><div class="line">//2、身份证  18位（前17位是数字，最后一位是数字或者X）；前六位：省市县；第七位到第十四位是出生年月日；最后四位是随机码，倒数第二位代表性别 奇数男 偶数女</div><div class="line">var str  = &apos;130424199712190017&apos;;</div><div class="line">var reg = /^(\d&#123;6&#125;)(\d&#123;4&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)\d&#123;2&#125;(\d)(?:\d|X)$/;</div><div class="line">console.log(str.match(reg));//-&gt;match:字符串的方法，捕获到正则匹配的结果，只要加上分组，在捕获的时候不仅把大正则匹配的捕获到，而且里面的每一个小分组（小正则）匹配的也可以单独的捕获到，如果其中有某一个分组不需要捕获（仅仅是改变优先级方便匹配），我们在分组的前面叫“？:”=&gt;只匹配不捕获</div><div class="line">[&quot;130424199712190017&quot;,&quot;130424&quot;,&quot;1997&quot;,&quot;12&quot;,&quot;19&quot;,&quot;1&quot;...]</div><div class="line"></div><div class="line">//3、验证是否为有效的数字  整数或者负数：可以以+或者-开头，再或者没有任何的符号开头；整数或者小数（如果是小数的话，必须要有点，点后面必须有数字才可以）；整数部分： 不能以0开头</div><div class="line">var reg =/^[+-]？(\d|([1-9]\d+))(\.\d+)?$/;</div><div class="line">//-&gt;([1-9]\d+)多位数不能以0开头A</div><div class="line">//-&gt;(\d\A) 一位数或者多位数 =&gt;整数</div><div class="line">//-&gt;()? 整个小数部分出现零到一次</div><div class="line"></div><div class="line">reg =/^(\+\-)?(\d\([1-9]\d+))(\.\d+)?$/;</div><div class="line">//-&gt;如何区分是第几个分组：按照小括号做半部分从左到右数即可（不分层级），数的过程中跳过?:、?=、?!，因为他们只匹配不捕获</div><div class="line"></div><div class="line">//4、验证是否为中文姓名 中文汉字 二到四位</div><div class="line">var reg =/^[\u4e00-\u9fa5]&#123;2,4&#125;$/;</div></pre></td></tr></table></figure>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2017/08/06/javascript-03 /">
    <time datetime="2017-08-06T09:36:06.951Z" class="entry-date">
        2017-08-06
    </time>
</a>
    
    
    </footer>
</article>


    
<nav class="nav-single">
    <h3 class="assistive-text">文章导航</h3>
    
        <span class="nav-previous"><a href="/2017/08/11/git/" rel="prev"><span class="meta-nav">←</span> (no title)</a></span>
    
    
        <span class="nav-next"><a href="/2017/08/06/linux/" rel="next">linux常用命令 <span class="meta-nav">→</span></a></span>
    
</nav><!-- .nav-single -->







</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value="" name="s" id="s" />
        <input type="submit" id="searchsubmit" value="搜索" />
    </div>
</form></aside>
  
    
  
    
  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/2017/09/06/echarts/">echarts</a>
          </li>
        
          <li>
            <a href="/2017/08/11/git/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/08/06/javascript-03 /">javascript-03</a>
          </li>
        
          <li>
            <a href="/2017/08/06/linux/">linux常用命令</a>
          </li>
        
          <li>
            <a href="/2017/07/18/javascript-02/">javascript 基本算法：排序，代码书写</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  
    
  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2017 卉卉
    All rights reserved.</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</footer>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>

<script src="/js/jquery-2.0.3.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
</body>
</html>